#语言整理：
# 一个有向图，每个结点u有且只有一条出边u->v,给定g数组
# g[u]=v 表示这条出边，求图中最长环的长度

#思路：
# dfs（u）表示当前访问节点U,集合s表示访问过的节点集合
# 如果u在s中，说明出现环
# 如果u不在s中，添加到集合中，并且访问后续节点dfs(g[u]) 
# 因为有且只有一条出边,只需要DFS一个G[u]就好
# 遍历所有节点,确保考虑所有的连通分量 对于每个连通分量,要去遍历它所有的入口
#考虑这样一个事情:假如它有两个连通分量块 举例,一个是1->2->1 一个是3->4->5->3 
#如果只考虑左边这个连通分量的话，右边的就被忽略掉了，那么我们进行一个整个连通分量块都进行访问
#如果整个连通分量块都进行访问的话，又得考虑这样一个事情：如访问2时又得再把整个连通分量块讨论一次
# 其实这里不需要这样讨论，因为拥有集合S，会把访问过的节点记录下来，当再试图从2进入连通分量过时，因为已经访问过了就不会再访问
# 类似代码：
# s = set
# def dfs(u):
#     if u in s:return 
#     s.add(u)
#     dfs(g[u])
#     #找到了环
#     for u in range(1,n+1): #外层循环，保证每个连通分量块有且只有访问过一次
#         dfs(u)
#那我们该怎么求解环的长度?

#时间戳思想，额外记录每次访问节点u的序号idx,字典d存放u:idx键值对
# 之前的集合s改成字典d，之前只会考虑访问了一个节点u，现在还会考虑访问到节点u的序号是几
#如1->3->6->4->3 假设1的idx是4 那么3是5 6是6 4是7 3是8
# 如果u在d中，说明第二次访问到u，构成闭环。
# 两次序号之差idx-d[u]即为环的长度 ---时间戳判断有向环的闭环和求环长思想
# 如果u不在d中，对字典进行维护更新添加到字典中，并且访问后续节点dfs(g[u],idx+1)
# 遍历所有节点，确保考虑所有的连通分量
# 在外层用res记录最大环长

# 正解代码：
import sys
input = lambda: sys.stdin.readline().rstrip()
sys.setrecursionlimit(10000) #设置递归深度至少大于n，因为py默认为1000
#setrecursionlimit(n) 设置递归深度函数
n=int(input())
g=[0]+list(map(int,input().split())) #因为下标从1开始而不是0开始
res=0
d={} #字典存放节点u:访问序号idx
def dfs(u,idx): #加了额外的变量idx 表示当前访问节点u的序号或叫时间戳
    global res #声明我现在使用的是全局变量res，否则相当于在函数体内部又定义了一个局部变量res
    if d.get(u) is not None: #每次去判断D是否包含本次的u，如果找到进行更新
        res=max(res,idx-d[u]) #更新最大环长
        return
    d[u]=idx #u不在d中，维护更新字典
    dfs(g[u],idx+1) #访问后续节点
    for u in range(1,n+1): #外层循环，保证每个连通分量块有且只有访问过一次
        if d.get(u) is None: #如果u不在d中，才访问
            dfs(u,1)
print(res)