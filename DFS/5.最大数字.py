# 思路：
# 1贪心，从左到右，尽可能构造9
# 对每一位数字，只会用一种操作
# 记dfs(i,n,a,b)表示当前考虑到第i位，剩下a次1号操作，b次2号操作，能构造的最大数字n
# 对于操作1.考虑d=min(9-x,a),即当前能够执行操作的次数
#  在本题中，0为数字的结束，每次只减1，10-x就是x变成0需要的次数，10-x-1就是x变成9需要的次数
# 则n<-nx10+(x+d),a<-a-d
# d是真正能够执行的操作次数 x加d是脱离题设实际上x的数字
# x加d加nx10 
# 以数字翻转为例子
#  n=1234 想反转为4321 
# 我们的做法是依次取这个数的最后一位，将临时数字x10，再加上这个数的最后一位
# 4231，0x10+4=4 4x10+3=43 43x10+2=432 432x10+1=4321 不借用字符串进行翻转的操作
# 这里的操作借用了以上思想，在第i位之前的数已经最大化为n，我们把前面的数x10同时加上i位（x能变到的最大的数）然后执行操作1或2的d，操作1就是x+d
#a-d表示还剩下的操作1次数，肯定不会越界，因为取了Min
# 对于操作2.考虑b是否大于等于x+1，是则可以得到9，且b<-b-(x+1)
#操作2要考虑b和x+1的关系，因为x+1是将x变成9需要的操作次数 如x=7，b=6不行
# b>=x+1，一定能够执行操作2，实际执行的次数就是x+1
#类似于DP问题，考虑某一位跟前位的状态转移方程
import sys
input=lambda:sys.stdin.readline().rstrip()
N,A,B=map(int,input().split())
sN=str(N)
res=0 #全局变量
def dfs(i,n,a,b):
    global res
    if i >= len(sN): #当i大于等于数字长度时，说明已经考虑完所有位 递归出口
        res=max(res,n)
        return
    
    x=int(sN[i]) #表示当前考虑到的这一位的值
    d=min(9-x,a) #表示当前能够执行操作1的次数
    dfs(i+1,n*10+(x+d),a-d,b) #把a进行更新,b原封不动，代表执行了操作1
    #n*10+(x+d)表示把前面的数乘以10加上当前位的数x加上d，对数值进行更新


    if b>=x+1: #考虑操作2，操作2执行的条件 b>=x+1
        dfs(i+1,n*10+9,a,b-(x+1))
dfs(0,0,A,B)
print(res)