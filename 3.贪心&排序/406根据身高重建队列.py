# 语言整理:有一群人排好队,每个人的身高为Hi,前面恰好有Ki个身高不小于他的人数
# 将(h1,k1),(h2,k2),...(hi,ki)...打乱,请你恢复原来的顺序

#  先语言整理,然后想思路,然后去整理思考过程,最后代码更新

# 思考过程:
# (hi,ki)到底能不能唯一确定先不管
# 恢复顺序一定要用排序
# ki为前面身高不小于他的人数,可以想到按照身高h降序排序,同时身高内部按ki升序排序
# 例子[5,0][5,1],[5,0]一定排在1的前面,因为内部排序里0前面没有人

#  手玩:把我们输入的数据在注释里或纸上画一下
#[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]
#[7,0],[7,1],[6,1],[5,0],[5,2],[4,4] 先按h降序 再按k的升序这个结果真的是我们想要的吗?
# [6,1]表示前面有1个人身高>=他,但按照这个排序,应该是2而不是1
# 先按h降序 再按k的升序 并不是最终的答案,还要进行操作

def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
    people.sort(key=lambda x:(-x[0],x[1]))
    # sort 排序方法,key用来指定函数
    # ((-x[0],x[1])) -x[0]表示按降序排,x[1]表示按升序排
# 首先，比较元组的第一个元素。(7,0)会排在(6,0)前面,只有第一个完全相同时,才排序第二个:
# 当(7,0)和(7,1)比较时,(7,0)排在(7,1)前面升序
# 但现在还不是我们想要的答案,还要再进行一个插入
#[7,0],[6,1],[7,1] 根据k值Insert 
    res = []
    for i,p in enumerate(people): #返回索引+元素本身的值,如[0->i,[7,0]->p]
        h,k =p[0],p[1] #身高,前面有多少人
        # 这是一个循环,变量 p 会在每一次循环中，依次等于 people 列表里的一个元素。
        if k == i:
            res.append(p)
        elif k<i:
            res.insert(k,p)
    return res
# 插入排序思想