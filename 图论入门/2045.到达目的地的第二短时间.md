[2045. 到达目的地的第二短时间](https://leetcode.cn/problems/second-minimum-time-to-reach-destination/)

困难



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



提示



城市用一个 **双向连通** 图表示，图中有 `n` 个节点，从 `1` 到 `n` 编号（包含 `1` 和 `n`）。图中的边用一个二维整数数组 `edges` 表示，其中每个 `edges[i] = [ui, vi]` 表示一条节点 `ui` 和节点 `vi` 之间的双向连通边。每组节点对由 **最多一条** 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 `time` 分钟。

每个节点都有一个交通信号灯，每 `change` 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 **同时** 改变。你可以在 **任何时候** 进入某个节点，但是 **只能** 在节点 **信号灯是绿色时** 才能离开。如果信号灯是 **绿色** ，你 **不能** 在节点等待，必须离开。

**第二小的值** 是 **严格大于** 最小值的所有值中最小的值。

- 例如，`[2, 3, 4]` 中第二小的值是 `3` ，而 `[2, 2, 4]` 中第二小的值是 `4` 。

给你 `n`、`edges`、`time` 和 `change` ，返回从节点 `1` 到节点 `n` 需要的 **第二短时间** 。

**注意：**

- 你可以 **任意次** 穿过任意顶点，**包括** `1` 和 `n` 。
- 你可以假设在 **启程时** ，所有信号灯刚刚变成 **绿色** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/09/29/e1.png)       ![img](https://assets.leetcode.com/uploads/2021/09/29/e2.png)

```
输入：n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5
输出：13
解释：
上面的左图展现了给出的城市交通图。
右图中的蓝色路径是最短时间路径。
花费的时间是：
- 从节点 1 开始，总花费时间=0
- 1 -> 4：3 分钟，总花费时间=3
- 4 -> 5：3 分钟，总花费时间=6
因此需要的最小时间是 6 分钟。

右图中的红色路径是第二短时间路径。
- 从节点 1 开始，总花费时间=0
- 1 -> 3：3 分钟，总花费时间=3
- 3 -> 4：3 分钟，总花费时间=6
- 在节点 4 等待 4 分钟，总花费时间=10
- 4 -> 5：3 分钟，总花费时间=13
因此第二短时间是 13 分钟。      
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)

```
输入：n = 2, edges = [[1,2]], time = 3, change = 2
输出：11
解释：
最短时间路径是 1 -> 2 ，总花费时间 = 3 分钟
第二短时间路径是 1 -> 2 -> 1 -> 2 ，总花费时间 = 11 分钟
```

 

**提示：**

- `2 <= n <= 104`
- `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`
- `edges[i].length == 2`
- `1 <= ui, vi <= n`
- `ui != vi`
- 不含重复边
- 每个节点都可以从其他节点直接或者间接到达
- `1 <= time, change <= 103`



```python
class Solution:
    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:
        #将节点(u,t)即(节点，时间)这一元组对作为新的节点
        e=[[]for _ in range(n+1)]
        for u,v in edges:
            e[u].append(v)
            e[v].append(u)
      	hq=[(0,1)]
        #(t//change)&1 == 0 绿色
        #(x,t)->(u,t + time)
        
        #(t//change)&1 == 1红色
        #需要change - t%change 时间进入下一个节点
        
        d,dd=[inf]* (n+1),[inf]*(n+1)
        d[1]=0
        
        #以下为堆优化：
        while hq:
            t,x = heapq.heappop(hq)
            if d[x]<t and dd[x]<t: #确认最小的和次小的
                continue
             for u in e[x]:
                nt = inf
          		if (t//change)&1 == 0:
                    nt = t +time
                else:
                    nt = t +change -t%change +time
            	if nt<d[u]:
                    d[u]=nt
                    heapq.heappush((nt,u))
                elif dd[u]>nt>d[u]:
                    dd[u]=nt
                    heapq.heappush(hq,(nt,u))
     	return dd[n]
```

