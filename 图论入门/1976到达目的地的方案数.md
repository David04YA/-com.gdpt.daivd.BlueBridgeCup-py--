[1976. 到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)

中等



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



提示



你在一个城市里，城市由 `n` 个路口组成，路口编号为 `0` 到 `n - 1` ，某些路口之间有 **双向** 道路。输入保证你可以从任意路口出发到达其他任意路口，且任意两个路口之间最多有一条路。

给你一个整数 `n` 和二维整数数组 `roads` ，其中 `roads[i] = [ui, vi, timei]` 表示在路口 `ui` 和 `vi` 之间有一条需要花费 `timei` 时间才能通过的道路。你想知道花费 **最少时间** 从路口 `0` 出发到达路口 `n - 1` 的方案数。

请返回花费 **最少时间** 到达目的地的 **路径数目** 。由于答案可能很大，将结果对 `109 + 7` **取余** 后返回。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2025/02/14/1976_corrected.png)

```
输入：n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
输出：4
解释：从路口 0 出发到路口 6 花费的最少时间是 7 分钟。
四条花费 7 分钟的路径分别为：
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
```

**示例 2：**

```
输入：n = 2, roads = [[1,0,10]]
输出：1
解释：只有一条从路口 0 到路口 1 的路，花费 10 分钟。
```

 

**提示：**

- `1 <= n <= 200`
- `n - 1 <= roads.length <= n * (n - 1) / 2`
- `roads[i].length == 3`
- `0 <= ui, vi <= n - 1`
- `1 <= timei <= 109`
- `ui != vi`
- 任意两个路口之间至多有一条路。
- 从任意路口出发，你能够到达其他任意路口。



# 思路

最短路Dijkstra+最短路DP：求原点0到任意节点i的最短路个数

```python
class Solution:
    def countPaths(self, n: int, roads: List[List[int]]) -> int:
        g=[[inf]*n for _ in range(n)]
        moder = 10 **9 +7
        for u,v,w in roads:
            g[u][v]=g[v][u]=w
            g[u][u]=g[v][v]=0
       	d=[inf]*n #dist数组，d[i]表示原点到i的最短路径长度
        d[0]=0
        v=[False]*n #节点访问标记
        mn,res=inf,0
        f=[0]*n #f[i]表示原点到i节点的最短路个数
        f[0]=1
        for _ in range(n-1):
            k=-1
            for u in range(n):
                if not v[u] and(x<0 or d[u]<d[x]):
                    x=u
         	v[x]=True
            for u in range(n):
                a=d[x]+g[x][u]
                if a<d[u]:#到u的最短路个数=经过x到u的个数=到x的最短路个数
                    d[u],f[u]=a,f[x]
                elif a== d[u]and u != x: #路径一样短，追加
                	f[u]=(f[u]+f[x])%moder
  		return f[n-1]
```

x from collections import defaultdictfrom typing import List​class Solution:    # 1. 修正函数签名，补上 source 参数    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:        # 特殊情况处理：如果起点和终点相同，直接返回 True        if source == destination:            return True​        # 2. 建图：使用邻接表表示图        #    这和你笔记 `建图.md` 中的邻接表思路是一样的        #    defaultdict(list) 的好处是，访问一个新节点时，会自动创建一个空列表        g = defaultdict(list)        for u, v in edges:            # 因为是双向图，所以需要添加两条边            g[u].append(v)            g[v].append(u)​        # 3. 准备DFS：创建一个集合 vis 用于记录访问过的节点        #    这可以防止在图里兜圈子（无限循环）        vis = set()​        # 4. 定义深度优先搜索 (DFS) 函数        def dfs(i):            # 递归终止条件：如果当前节点 i 是终点，说明找到路径，返回 True            if i == destination:                return True            vis.add(i)            for j in g[i]:                # 核心：如果邻居 j 没有被访问过，就继续对 j 进行深度优先搜索                # 如果从 j 出发能找到终点，就层层返回 True                if j not in vis and dfs(j):                    return True            # 如果当前节点的所有邻居都走不通，返回 False            return False​        # 5. 从起点 source 开始执行搜索        return dfs(source)python
