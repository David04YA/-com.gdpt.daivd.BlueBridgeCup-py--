# 建图

给定$n$个节点,$m$条边，$m$条边的信息（如下所示）。我们希望用$g(u,v)$表示$u,v$的信息（如连通性、边权）。

每一条用一个三元组$u,v,w$表示$u,v$这两个节点之间存在一条边长（边权）为$w$的一条边。

> 5 6
>
> 0 1 2
>
> 1 2 5
>
> 0 3 3
>
> 1 3 4
>
> 3 4 7
>
> 3 2 10

![image-20251003124133834](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251003124133834.png)

去维护$g(u,v)$的连通性或边权长度的问题



## 邻接矩阵

###  思路：

对于一个共有$n$个节点的图，可以用一个$N×N$的矩阵去存储。对于其中的$u行v列以及v行u列$同时赋值一个小格子，值为边长(边权)

#### 带权无向图

- 初始值设置为$inf$表示不相通，即距离无穷大 

  > - 初始的时候，节点间应该是两两不相连的

- $g(x,x)$应为0

#### 带权无向图用零点矩阵建图的模板

```python
from math import inf #内置库里的包
n,m = map(int.input().split())
g = [[inf]*n for _ in range(n)] #初始值先设置为正无穷大
for _in range(m):
	u,v,w=map(int,input().split)
    g[u][v]=g[v][u]=w #双向边
    g[u][u]=g[v][v]=0 #原地不动，距离是0
```

#### 输出样例

```python
[0,2,inf,3,inf]
[2,0,5,4,inf]
[inf,5,0,10,inf]
[3,4,10,0,7]
[inf,inf,inf,7,0]
```

> 可以发现上述例子呈轴对称关系（如0，7等数字）
>
> 原因是在无向图中要进行镜像存储$g[u][v]=g[v][u]$



## 邻接表

### 1.带权无向图

#### 思路：

对于一个稀疏图，使用矩阵会造成资源浪费。

> 对于一个共N个节点的边，我们最多可以连接上N×N-12条边，即一个$O(n^2)$级别的一个边。
>
> 而稀疏图里，边的数量远远小于节点的数量（如共有1W个节点，却只有1条边），再使用邻接矩阵就会创造出很多个Inf边，浪费了很多空间，此时可以使用邻接表的方式存储



```python
n,m=map(int,input().split())
e=[[] for _ in range(n)]  #共有n个元素，每个元素是一个空列表
for _ in range(m): #共有m条边
    u,v,w=map (int,input().split()) #接收三元组
    e[u].append((v,w))
    e[v].append((u,w))#由于是无向图，uv加的边，vu也要加
```

![image-20251005162619074](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251005162619074.png)

```python
[(1,2),(2,3)] #节点0，会有012 033
[(0,2),(2,5),(3,4)]#节点1 有102 125 134
[(1,5),(3,10)]
[(0,3),(1,4),(4,7),(2,10)]
[(3,7)]
```

> 通过邻接表，
>
> 1. 可以快速的知道我们的节点的邻接邻居个数是多少，通过len()方法就能知道
> 2. 同时，这种存储节点与节点，节点与边的存储形式，对于稀疏图可以节省空间

### 2带权有向图:

![image-20251005171758789](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251005171758789.png)

> 如图所示，有向图的意思是节点间只有一条单向边

```python
n,m=map(int,input().split())
e=[[] for _ in range(n)]
for _ in range(m):
    u,v,w = map(int,input().split())
    e[u].append((v,w))#由于是单向边，所以不需要e[v].append((u,w))
```

### 3.不带权有向图

```python
n,m=map(int,input().split())
e=[[] for _ in range(n)]
for _ in range(m):
    e[u].append(v) #因为不考虑边权，所以省略w这个维度
```

### 4.DFS序（邻接表版）

![image-20251005172955116](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251005172955116.png)

```python
s=set() #初始化一个集合，用于记录已经访问过的节点
def dfs(u):
     s.add(u) #将当前节点添加到集合s中
    for v,_ in e[u]:  #e[u]=(v,w)
        if v not in s: #检查邻居节点是否被访问过
            dfs(v)
```

![image-20251005221408643](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251005221408643.png)

```python
n,m=map(int,input().split())
e=[[] for _ in range(n)]
for _ in range(m):
    u,v,w=map(int,input().split())
    e[u].append((v,w))
    e[v].append((u,w))
s=set()#已经访问的
def dfs(u):
    #遍历当前节点的操作，如输出节点信息等
    print(u,end='')
    s.add(u)
    
    #遍历邻居
    for v,_ in e[u]:
        if v not in s:
            dfs(v)
dfs(0) #0 1 2 3 4
print()
s.clear()
dfs(4)#4 3 0 1 2
```

> 借助集合的特性，我们能够完成让所有的节点通过DFS方法不重不漏的访问并记录



### 5.Dijkstra：

求解 **非负权图**上单源最短路径

> 非负权重就是边权不能出现负数（-1等）

该问题是用来求解到达原点或某节点的最短路径 

![image-20251006144617298](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251006144617298.png)

> 如下图所示，把原点设置为0，求解0到2的的最短路径是多少->即为2+5=7

![image-20251006144016415](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251006144016415.png)

#### 朴素Dijkstra

适用于稠密图，时间复杂度：$O(n^2)$

```python
d=[inf] * n #其他所有节点到达原点的一个最短的距离，初始设置为正无穷大
d[0]=0 #原点是0，0到0的距离是0
s=set() #s集合为已经确定的节点集合->已经找到的所有在S集合里面的节点到达原点的最短路径的长度
#如，原点是0，这时d[0]=0，把节点0添加进集合s中
for _ in range(n -1):#当操作到n-1次时，n-1个节点已经筛完，剩下的1个节点不用筛了
    x=-1  #-1代表还没找到中间节点
    #从U-S（集合）中找出距离s（原点）最近的节点
    for u in range(n):
        if u not in s and(x<0 or d[u] <d[x]): #不在集合S里并且d(u)是更小的
            x=u
  	s.add(x)
    #以上是操作1，找出距离最小的，把它加到集合S里
    
    
    for u in range(n):
        d[u]=min(d[u],d[x] +g[u][x]) #去比较两段路径谁更小
```

>  #松弛，对每个节点判断以x作为中间节点去更新其他所有节点的距离，是否距离原点更近，就是松弛操作
>     #如上，需要把除0节点外的其他节点考虑一下，把0作为一个中间节点，能否距离原点更近->考虑d[x]+g[u][x]和d[u]的关系 以节点1为例，考虑1到0的距离+0到0的距离和1本身到0的距离谁更近
>     #它的思想：每次找到一个中间节点x,这个x是所有节点里距离原点最近的节点，然后对于剩下没有答案的节点，去考虑能否借用当前的x作为中间节点进行松弛操作
>     #如下图所示

![QQ_1759758463508](C:\Users\26705\AppData\Local\Temp\QQ_1759758463508.png)

> 更新如下所示，以0为中间节点

![QQ_1759759404541](C:\Users\26705\AppData\Local\Temp\QQ_1759759404541.png)

> 更新如下所示，以1为中间节点，以此类推，接着进行下轮操作，共进行n-1次，直到只剩一个节点，自然就可以作为最后一个节点添加到集合里

![QQ_1759759950218](C:\Users\26705\AppData\Local\Temp\QQ_1759759950218.png)

#### 总结：

**迪杰斯特拉思想**：定义一个集合S，表示的是已经确定的，到原点最短路径的集合 

每次从不在这个集合S里面的所有节点里面，找到一个距离原点最近的节点，把它加到集合S中，然后更新集合S，更新完后把这个节点作为中间节点进行松弛操作 <!--松弛操作就是，从直接观察节点到原点的距离，变成观察节点到中间节点的距离，它们到底谁更小，然后取Min。至于为什么这么做能行得通，涉及到数学证明这里不细讲-->



```python
from math import inf
n,m=map(int,input().split())
g=[[inf]*n for _ in range(n)]
for _ in range(m):
    u,v,w=map(int,input().split())
    g[u][v]=g[v][u]=n
    g[u][u]=g[v][v]=0
d=[inf]*n
d[4]=0 #把4作为原点
s=set()

for _ in range(n-1):
    x=-1
    for u in range(n):
        if  u not in s and(x<0 or d[u]<d[x]):
            x=u
  	s.add(x)
    
    for u in range(n):
        d[u]=min(d[u],d[x]+g[u][x])
print(d)
```



#### Dijkstra堆优化：不是重点，一般用朴素就好

**堆优化Dijkstra**

适用于稀疏图（点个数的平方远大于边的个数），复杂度为$O(mlogm)$,m为边的个数。

使用小根堆，存放未确定最短路点集对应的（d[i],i)。对于同一个i可能存放多组不同d[i]的元组，因此堆中元素的个数最多是$m'$

寻找最小值的过程可以用一个最小堆快速完成

```python
e=[[] for _ in range(n)]
for u,v,w in roads:
    e[u].append((v,w))
    e[v].append((u,w))
    
    
d=[inf]*n
d[0]=0
hq=[(0,0)]#小根堆，存放未确定最短路点集
while hq:
    dx,x=heapq.heappop(hq)
    #复杂度O(mlogm)是因为把找不在S里的最短的d优化成堆的问题，优化成堆问题就变成了考虑跟边的数量的关系
    if dx>d[x]:continue #跳出重复出堆，首次出堆一次是最短路
    for u,w in e[x]:
        a=d[x]+w
        if a<d[u]:
            d[u]=a #同一个节点u的最短路d[u]在出堆前会被反复更新
            heapq.heappush(hq,(a,u))
```



### Floyd

求解带权图上 **多源最短路**

> 区别于常规问题:由一个源点去求其他节点到它自己的最短路的长度

给定$n$个节点，$m$条边的带权无向图，和$q$组询问，每次需要回答$u,v$的最短路径长度

- 考虑$u,v$路径上的中间节点$k$，拆分成$u->k$的最短路径长度+$k->v$的最短路径长度
- $k$代表当前允许使用的中间节点，$k$遍历$[0,n-1]$，对于每个$k$对整个邻接矩阵进行更新
- $g[u][v]=min(g[u][v],g[u][k]+g[k][v])$
- 为什么$k$不能放在其他位置？放在最外层，对每个$k$从左上到右下进行一次更新，能够有效利用之前的值。放在最内层，每处$(u,v)$局部更新，不能有效利用之前的值。

时间复杂度$O(n^3)$

```python
for _ in range(m):
    u,v,w = map(int,input().split())
    g[u][v]=g[v][u]=w
    g[u][u]=g[v][v]=0
for k in range(n): #K的遍历
    for u in range(n):
        for v in range(n): #把二维邻接矩阵从左上到右下进行遍历
            g[u][v]=min(g[u][v],g[u][k]+g[k][v]) #正是因为k循环放在最外层，所以这里能利用到前面所有的值，保证最优解
```



```python
from math import inf
n,m=map(int,input().split())
g=[[inf]* n for _ in range(n)] #初始值设为无穷大
for _ in range(m):
    u,v,w = map(int,input().split())
    g[u][v]=g[v][u]=w#最开始只能存储g[u][v]的直接路
    g[u][u]=g[v][v]=0
for k in range(n): #K的遍历
    for u in range(n):
        for v in range(n): 
            g[u][v]=min(g[u][v],g[u][k]+g[k][v]) #这里没有定义新数组，直接在原始矩阵上更改 g[u][v]直接表示任意u到v的最短路径
print(g)
```



## 一种适用于任何算法的思想：

先理清楚算法的逻辑，再去看代码

