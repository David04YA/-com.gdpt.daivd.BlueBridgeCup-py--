[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

中等



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



提示



有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```

**示例 2：**

```
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
```

**示例 3：**

```
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
```

 

**提示：**

- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）



# 思路

是一个将无向图转化为有向图的问题



```python
class Solution:
    def networkDelayTime(self,e:List[List[int]],n:int,k:int)->int:
        g=[[inf]*(n+1) for _ in range(n+1)] 
        for i in range(m):
            u,v,w=e[i]
            g[u][v]=w
            g[u][u]=g[v][v]=0
            
      	d=[inf]*(n+1)
        d[k]=0
        s=set() 
        
        for _ in range(n-1):
            x=-1
            for u in range(1,n+1):
                if u not in s and(x<0 or d[u]<d[x]):
                    x=u
                    
     	for u in range(1,n+1)：
        	d[u]=min(d[u],d[x]+g[x][u]) #g[x][u]还是g[u][x]需要注意
      	res = max(d[1:])
        return res if res<inf else -1
```

