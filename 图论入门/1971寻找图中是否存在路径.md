[1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)

简单



相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。

给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)

```
输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2 
- 0 → 2
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png)

```
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.
```

 

**提示：**

- `1 <= n <= 2 * 105`
- `0 <= edges.length <= 2 * 105`
- `edges[i].length == 2`
- `0 <= ui, vi <= n - 1`
- `ui != vi`
- `0 <= source, destination <= n - 1`
- 不存在重复边
- 不存在指向顶点自身的边



# 方法1：DFS

我们先将 `edges`转换为图 `g`，然后使用DFS，判断是否存在从 `source`到 `destination`的路径。

过程中，用数组 `vis`记录已经访问过的顶点，避免重复访问

时间复杂度$O(n+m)$,其中n和m分别是节点数和边数

```python
from collections import defaultdict
from typing import List

class Solution:
    # 1. 修正函数签名，补上 source 参数
    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:
        # 特殊情况处理：如果起点和终点相同，直接返回 True
        if source == destination:
            return True

        # 2. 建图：使用邻接表表示图
        #    这和你笔记 `建图.md` 中的邻接表思路是一样的
        #    defaultdict(list) 的好处是，访问一个新节点时，会自动创建一个空列表
        g = defaultdict(list)
        for u, v in edges:
            # 因为是双向图，所以需要添加两条边
            g[u].append(v)
            g[v].append(u)

        # 3. 准备DFS：创建一个集合 vis 用于记录访问过的节点
        #    这可以防止在图里兜圈子（无限循环）
        vis = set()

        # 4. 定义深度优先搜索 (DFS) 函数
        def dfs(i):
            # 递归终止条件：如果当前节点 i 是终点，说明找到路径，返回 True
            if i == destination:
                return True
            vis.add(i)
            for j in g[i]:
                # 核心：如果邻居 j 没有被访问过，就继续对 j 进行深度优先搜索
                # 如果从 j 出发能找到终点，就层层返回 True
                if j not in vis and dfs(j):
                    return True
            # 如果当前节点的所有邻居都走不通，返回 False
            return False

        # 5. 从起点 source 开始执行搜索
        return dfs(source)
```
