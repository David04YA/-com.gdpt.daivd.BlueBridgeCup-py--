套路】教你解决定长滑窗！适用于所有定长滑窗题目！（Python/Java/C++/C/Go/JS/Rust）

[灵茶山艾府](https://leetcode.cn/u/endlesscheng/)

![2022 感恩勋章](https://pic.leetcode.cn/1672297038-gOvOPc-%E6%8E%A5%E5%8F%97%E6%84%9F%E6%81%A9sm.png)



123391



2024.06.13

发布于 浙江

滑动窗口

C

C++

Go

## 核心思想

我们要计算所有长度**恰好**为 *k* 的子串中，最多可以包含多少个元音字母。

暴力枚举所有子串？时间复杂度是 O(*nk*)，太慢了。能否 O(1) 计算子串的元音个数？

这是可以做到的，对于下图的字符串 abci，假如我们已经计算出了子串 abc 的元音个数，那么从子串 abc 到子串 bci，只需要考虑移除（离开窗口）的字母 a 是不是元音，以及添加（进入窗口）的字母 i 是不是元音即可，因为中间的字母 b 和 c 都在这两个子串中。

![lc1456.png](https://pic.leetcode.cn/1718242805-sqSjqc-lc1456.png)

## 举例

示例 1，*s*=abciiidef, *k*=3。

1. 从左到右遍历 *s*。
2. 首先统计前 *k*−1=2 个字母的元音个数，这有 1 个。
3. *s*[2]=c 进入窗口，此时找到了第一个长为 *k* 的子串 abc，现在元音个数有 1 个，更新答案最大值。然后 *s*[0]=a 离开窗口，现在元音个数有 0 个。
4. *s*[3]=i 进入窗口，此时找到了第二个长为 *k* 的子串 bci，现在元音个数有 1 个，更新答案最大值。然后 *s*[1]=b 离开窗口，现在元音个数有 1 个。
5. *s*[4]=i 进入窗口，此时找到了第三个长为 *k* 的子串 cii，现在元音个数有 2 个，更新答案最大值。然后 *s*[2]=c 离开窗口，现在元音个数有 2 个。
6. *s*[5]=i 进入窗口，此时找到了第四个长为 *k* 的子串 iii，现在元音个数有 3 个，更新答案最大值。然后 *s*[3]=i 离开窗口，现在元音个数有 2 个。
7. *s*[6]=d 进入窗口，此时找到了第五个长为 *k* 的子串 iid，现在元音个数有 2 个，更新答案最大值。然后 *s*[4]=i 离开窗口，现在元音个数有 1 个。
8. *s*[7]=e 进入窗口，此时找到了第六个长为 *k* 的子串 ide，现在元音个数有 2 个，更新答案最大值。然后 *s*[5]=i 离开窗口，现在元音个数有 1 个。
9. *s*[8]=f 进入窗口，此时找到了第七个长为 *k* 的子串 def，现在元音个数有 1 个，更新答案最大值。遍历结束。

## 定长滑窗套路

窗口右端点在 *i* 时，由于窗口长度为 *k*，所以窗口左端点为 *i*−*k*+1。

我总结成三步：**入-更新-出**。

1. **入**：下标为 *i* 的元素进入窗口，更新相关统计量。如果窗口左端点 *i*−*k*+1<0，则尚未形成第一个窗口，重复第一步。
2. **更新**：更新答案。一般是更新最大值/最小值。
3. **出**：下标为 *i*−*k*+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。

以上三步适用于所有定长滑窗题目。

## 答疑

**问**：为什么窗口右端点为 *i* 的时候，左端点是 *i*−*k*+1？

**答**：对于窗口（闭区间）[*L*,*R*] 来说，[*L*,*R*] 里面的元素个数为 *R*−*L*+1。比如 [2,5] 里面有 2,3,4,5 一共 5−2+1=4 个数。如果窗口大小为 *k*，即 *R*−*L*+1=*k*，解得 *L*=*R*−*k*+1。所以右端点为 *R* 的时候，左端点为 *R*−*k*+1。

```py
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        ans = vowel = 0
        for i, c in enumerate(s):  # 枚举窗口右端点 i
            # 1. 右端点进入窗口
            if c in "aeiou":
                vowel += 1

            left = i - k + 1  # 窗口左端点
            if left < 0:  # 窗口大小不足 k，尚未形成第一个窗口
                continue

            # 2. 更新答案
            ans = max(ans, vowel)

            # 3. 左端点离开窗口，为下一个循环做准备
            if s[left] in "aeiou":
                vowel -= 1
        return ans
```

## 优化

答案的最大值是 *k*，即窗口中全是元音。

如果发现答案等于 *k*，由于答案无法再变大，可以退出循环。

```py
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        ans = vowel = 0
        for i, c in enumerate(s):  # 枚举窗口右端点 i
            # 1. 右端点进入窗口
            if c in "aeiou":
                vowel += 1

            left = i - k + 1  # 窗口左端点
            if left < 0:  # 窗口大小不足 k，尚未形成第一个窗口
                continue

            # 2. 更新答案
            ans = max(ans, vowel)
            if ans == k:  # 答案已经等于理论最大值
                break  # 无需再循环

            # 3. 左端点离开窗口，为下一个循环做准备
            if s[left] in "aeiou":
                vowel -= 1
        return ans
```

#### 复杂度分析

- 时间复杂度：O(*n*)，其中 *n* 是 *s* 的长度。
- 空间复杂度：O(1)。