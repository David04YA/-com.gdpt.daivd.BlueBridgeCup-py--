# # # # 我的尝试:class Solution:
# # # #     def maxScore(self, s: str) -> int:
# # # #         #定义出两个空字符串 定义一个返回值int
# # # #         n=[]
# # # #         m=[]
# # # #         res=0
# # # #         for i in range(len(s)):
# # # #             while s[i]==0:
# # # #              n.append(s[i])
# # # #             while s[i]==1:
# # # #              m.append(s[i])
# # # #              return n,m
# # # #         x=len(n)
# # # #         y=len(m)
# # # #         return x+y

# # # # 题目要求分析:
# # # # 将字符串 s 分割成 左 和 右 两个 非空 的子字符串。
# # # # 对于 每一种 分割方式，计算一个得分：左边子串中'0'的数量 + 右边子串中'1'的数量。
# # # # 在所有可能的得分中，找到 最大 的那个。

# # # # 逻辑问题：
# # # # 你的代码似乎是想把字符串中所有的 '0' 放到列表 n，所有的 '1' 放到列表 m。这不符合题目“分割成左右两部分”的要求。题目中的左右子串是根据分割位置决定的，而不是根据字符是'0'还是'1'。

# # # 循环和返回问题：
# # # while s[i]==0: 和 while s[i]==1: 会导致无限循环。例如，如果 s[i] 是 '0'，程序会一直执行 n.append(s[i])，永远不会退出 while 循环。
# # # return n,m 在 while s[i]==1: 循环内部，这意味着只要遇到第一个 '1'，函数就会立即结束并返回，后面的字符都不会被处理。

# # 正确的解题思路 (暴力解法)
# # 最直观的方法就是模拟题目的要求：遍历每一个可能的分割点，计算得分，然后取最大值。

# # 确定分割范围：因为左右子串都不能为空，所以分割点可以从索引 1 开始，直到字符串的末尾（不包括末尾）。如果字符串长度为 L，那么分割点 i 可以是 1, 2, ..., L-1。
# # 遍历：写一个循环，让 i 从 1 遍历到 L-1。
# # 分割：在每次循环中，s[0:i] 就是左子串，s[i:L] 就是右子串。
# # 计算得分：
# # 计算左子串中 '0' 的数量。
# # 计算右子串中 '1' 的数量。
# # 两者相加得到当前分割的得分。
# # 更新最大值：维护一个变量 max_score，每次计算出新得分后，都和 max_score 比较，保留较大的那个。
# # 返回结果：循环结束后，max_score 就是最终答案。


# 优化思路
# 暴力解法每次分割都要重新计算左右子串中'0'和'1'的数量，这有点重复。我们可以优化一下：

# 一次遍历：我们只遍历一次字符串，从左到右移动分割点。
# 维护计数：
# 定义两个变量：zeros_left (左边0的数量) 和 ones_right (右边1的数量)。
# 一开始，我们可以假设分割点在索引1处。zeros_left 就是第一个字符是不是'0'，ones_right 就是从第二个字符到末尾所有'1'的数量。
# 然后我们向右移动分割点 i：
# 检查 s[i]：如果它是 '0'，zeros_left 就加 1。如果它是 '1'，ones_right 就减 1（因为它从右边移到了左边）。
# 每次移动后，都计算 zeros_left + ones_right，并更新最大分。
# 这个优化方法只需要遍历一次字符串，效率更高。