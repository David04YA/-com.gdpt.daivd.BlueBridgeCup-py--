# 合并链表与分解链表的不同点

## 1.是否成环

合并链表没有成环的风险。而分隔链表有

![partition](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\partition.jpg)

上图是一个分解链表操作，它需要进行：

1. 获得原链表指针
2. 将原链表节点按要求放入新空链表中
3. 将两个链表头尾相接

成环风险的原因是3头尾相接，而合并链表不需要该操作 

## 2.代码实现上

在分解链表中，为了避免成环风险，我们会将首尾相接这样做：

```python
 # 不能直接让 p 指针前进，
            # p = p.next
            # 断开原链表中的每个节点的 next 指针
            temp = p.next
            p.next = None
            p = temp
        # 连接两个链表
        p1.next = dummy2.next

        return dummy1.next
```

而在合并（有序）链表中，由于不用考虑成环风险，我们这样做：

```python
   # p 指针不断前进
            p = p.next
            
        return dummy.next
```



分隔链表完整代码如下：

```python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # 存放小于 x 的链表的虚拟头结点
        dummy1 = ListNode(-1)
        # 存放大于等于 x 的链表的虚拟头结点
        dummy2 = ListNode(-1)
        # p1, p2 指针负责生成结果链表
        p1, p2 = dummy1, dummy2
        # p 负责遍历原链表，类似合并两个有序链表的逻辑
        # 这里是将一个链表分解成两个链表
        p = head
        while p:
            if p.val >= x:
                p2.next = p
                p2 = p2.next
            else:
                p1.next = p
                p1 = p1.next
            # 不能直接让 p 指针前进，
            # p = p.next
            # 断开原链表中的每个节点的 next 指针
            temp = p.next
            p.next = None
            p = temp
        # 连接两个链表
        p1.next = dummy2.next

        return dummy1.next
```



合并有序链表完整代码如下：

```python
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    # 重载比较运算符，方便将 ListNode 加入最小堆
    def __lt__(self, other):
        return self.val < other.val

class Solution:
    def mergeKLists(self, lists):
        if not lists:
            return None
        # 虚拟头结点
        dummy = ListNode(-1)
        p = dummy
        # 优先级队列，最小堆
        pq = []
        # 将 k 个链表的头结点加入最小堆
        for i, head in enumerate(lists):
            if head is not None:
                heapq.heappush(pq, (head.val, i, head))

        while pq:
            # 获取最小节点，接到结果链表中
            val, i, node = heapq.heappop(pq)
            p.next = node
            if node.next is not None:
                heapq.heappush(pq, (node.next.val, i, node.next))
            # p 指针不断前进
            p = p.next
            
        return dummy.next
```

# 对最小堆（优先级队列）的掌握

当我们解决**有序题目**时，我们往往需要导入最小堆来为数据排序。

```python
import heapq

#创建一个优先级队列
pq=[]

#加入最小堆
heapq.heappush(pq,(val1,val2,val3,....))

#最小堆里弹出最小值
heapq.heappop(pq)
```



# 快慢指针的应用

## 快慢指针的概念

创建两个指针p1,p2，让两个指针发生追逐。可以追逐成功也可以不追逐成功，可以速度相同也可以速度不同，可以起点相同也可以起点不同

## 快慢指针在链表上的常见场景

### 查找单链表上倒数第K个节点

> 让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步。再用一个指针 `p2` 指向链表头节点 `head`。
>
> 接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：

```python
# 返回链表的倒数第 k 个节点
def findFromEnd(head: ListNode, k: int) -> ListNode:
    p1 = head
    # p1 先走 k 步
    for i in range(k):
        p1 = p1.next
    p2 = head
    # p1 和 p2 同时走 n - k 步
    while p1 != None:
        p2 = p2.next
        p1 = p1.next
    # p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2
```

> **有查找就有增删改，让我来介绍如何实现增删改，与单纯查找有一点区别**

### 删除链表的倒数第N个节点

![image-20251118214525019](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251118214525019.png)

如图所示，删除节点4

```python
# 主函数
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # 虚拟头结点
        dummy = ListNode(-1)
        dummy.next = head
        # 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        x = self.findFromEnd(dummy, n + 1)
        # 删掉倒数第 n 个节点
        x.next = x.next.next
        return dummy.next
        
    def findFromEnd(self, head: ListNode, k: int) -> ListNode:
        # 代码见上文
        pass
```

要删除倒数第`n`个节点，就要获取到倒数第`n+1`个节点的引用。为了防止空指针的现象，要使用虚拟头节点。比如一共有5个节点，现在要删除倒数第五个头节点，前面已经没有节点了。

### 查找单链表的中点

创建两个指向头节点的指针`slow`和`fast`，令`slow`每次进1，`fast`每次进2，结束条件为`fast`走到链表末尾，就实现了查询链表中点

```python
class Solution:
    # 快慢指针初始化指向 head
    def middleNode(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        # 快指针走到末尾时停止
        while fast is not None and fast.next is not None:
            # 慢指针走一步，快指针走两步
            slow = slow.next
            fast = fast.next.next
        # 慢指针指向中点
        return slow
```

> 需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

## 判断是否成环

每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终能正常走到链表末尾，说明链表中没有环；如果 `fast` 走着走着竟然和 `slow` 相遇了，那肯定是 `fast` 在链表中转圈了，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```python
class Solution:
    # 快慢指针初始化指向 head
    def hasCycle(self, head: ListNode) -> bool:
        slow = head
        fast = head
        # 快指针走到末尾时停止
        while fast is not None and fast.next is not None:
            # 慢指针走一步，快指针走两步
            slow = slow.next
            fast = fast.next.next
            # 快慢指针相遇，说明含有环
            if slow == fast:
                return True
        # 不包含环
        return False
```

#### 如果链表中含有环，如何计算这个环的起点？

![circularlinkedlist](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\circularlinkedlist.png)

```python
class Solution:
    def detectCycle(self, head: ListNode):
        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        
        # 上面的代码类似 hasCycle 函数
        if not fast or not fast.next:
            # fast 遇到空指针说明没有环
            return None
        
        # 重新指向头结点
        slow = head 
        # 快慢指针同步前进，相交点就是环起点
        #至于为什么，这里设计数学证明
        while slow != fast:
            fast = fast.next
            slow = slow.next
        return slow
```

##### 对第二次快慢指针相交点是环起点的证明

已知 fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next

![image-20251120181827989](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251120181827989.png)

由于它们在同一时间从同一点 (`head`) 出发，并在同一点 **相遇**，这说明快指针比慢指针**多走了一圈或多走了 $n$ 圈的距离**。	![image-20251120181838178](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251120181838178.png)

因为快慢指针都在环内沿着环移动，快指针要追上慢指针，**多走的距离 $k$ 必须是由绕环产生的**。

$$k = n \cdot R \quad (\text{其中 } n \ge 1 \text{，} R \text{ 是环长})$$

要让 `fast` 追上 `slow`，`fast` 必须比 `slow` **精确地多走完 $n$ 个环的长度 $R$。** 否则，如果多走的距离 $k$ 不等于 $R$ 的整数倍，它们在环内就永远不会到达同一个节点。

## 双指针的应用

1. 合并链表
2. 分解链表
3. 两个链表是否相交
