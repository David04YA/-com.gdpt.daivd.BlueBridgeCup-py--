# 双指针技巧秒杀七道链表题目

> 本文讲解的例题
>
> |                           LeetCode                           |                             力扣                             | 难度 |
> | :----------------------------------------------------------: | :----------------------------------------------------------: | :--: |
> | [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) | [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) |  🟢   |
> | [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) | [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/) |  🟠   |
> | [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/) | [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) |  🟢   |
> | [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/) | [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) |  🟠   |
> | [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) | [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/) |  🟢   |
> | [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) | [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/) |  🔴   |
> | [86. Partition List](https://leetcode.com/problems/partition-list/) | [86. 分隔链表](https://leetcode.cn/problems/partition-list/) |  🟠   |
> | [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) | [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/) |  🟢   |
> |                              -                               | [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) |  🟢   |

> ## 前置知识

> 阅读本文前，你需要先学习：
>
> - [链表基础](https://labuladong.online/algo/data-structure-basic/linkedlist-basic/)

本文总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、链表的分解

3、合并 `k` 个有序链表

4、寻找单链表的倒数第 `k` 个节点

5、寻找单链表的中点

6、判断单链表是否包含环并找出环起点

7、判断两个单链表是否相交并找出交点

这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。

## [合并两个有序链表](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#合并两个有序链表)

这是最基本的链表技巧，力扣第 21 题「[合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)」就是这个问题，给你输入两个有序链表，请你把他俩合并成一个新的有序链表：

> **21. 合并两个有序链表** | [力扣](https://leetcode.cn/problems/merge-two-sorted-lists/) | [LeetCode](https://leetcode.com/problems/merge-two-sorted-lists/) | 🟢
>
> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
>
> **示例 1：**
>
> ![img](https://labuladong.online/algo/images/lc/uploads/2020/10/03/merge_ex1.jpg)
>
> ```
> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```
>
> **示例 2：**
>
> ```
> 输入：l1 = [], l2 = []
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：l1 = [], l2 = [0]
> 输出：[0]
> ```
>
> **提示：**
>
> - 两个链表的节点数目范围是 `[0, 50]`
> - `-100 <= Node.val <= 100`
> - `l1` 和 `l2` 均按 **非递减顺序** 排列
>
> **题目来源：[力扣 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)。**

```python
# 函数签名如下
def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
```

这题比较简单，我们直接看解法：

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 虚拟头结点
        dummy = ListNode(-1)
        p = dummy
        p1 = l1
        p2 = l2
        
        while p1 is not None and p2 is not None: 
            # 比较 p1 和 p2 两个指针
            # 将值较小的的节点接到 p 指针
            if p1.val > p2.val:
                p.next = p2
                p2 = p2.next
            else:
                p.next = p1
                p1 = p1.next
            # p 指针不断更新前进，从dummy->1->2....
            p = p.next 
        
        #while循环在p1,p2一个链表遍历完后结束，这里是为了更健壮
        if p1 is not None:
            p.next = p1
        
        if p2 is not None:
            p.next = p2
        
        return dummy.next
    #return dummy.next 的确只返回了一个节点对象，但它也有next指向下一个对象，返回它就返回了一整个链表
```

​	

我们的 while 循环每次比较 `p1` 和 `p2` 的大小，把较小的节点接到结果链表上，看如下 GIF：

![1](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\1.gif)

形象地理解，这个算法的逻辑类似于拉拉链，`l1, l2` 类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并。

下面是算法的可视化，你可以多次点击`while(p1 != null && p2 != null)`这一行代码，即可看到 合并两个有序链表的过程：

[合并有序链表的可视化](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#div_merge-two-sorted-lists)

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会复杂一些，需要额外处理指针 `p` 为空的情况。而有了 `dummy` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

## 何时使用虚拟头结点

经常有读者问我，什么时候需要用虚拟头结点？我这里总结下：**当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理**。

比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。

## [单链表的分解](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#单链表的分解)

直接看下力扣第 86 题「[分隔链表](https://leetcode.cn/problems/partition-list/)」：

> **86. 分隔链表** | [力扣](https://leetcode.cn/problems/partition-list/) | [LeetCode](https://leetcode.com/problems/partition-list/) | 🟠
>
> 给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。
>
> 你应当 **保留** 两个分区中每个节点的初始相对位置。
>
> **示例 1：**
>
> ![img](https://labuladong.online/algo/images/lc/uploads/2021/01/04/partition.jpg)
>
> ```
> 输入：head = [1,4,3,2,5,2], x = 3
> 输出：[1,2,2,4,3,5]
> ```
>
> **示例 2：**
>
> ```
> 输入：head = [2,1], x = 2
> 输出：[1,2]
> ```
>
> **提示：**
>
> - 链表中节点的数目在范围 `[0, 200]` 内
> - `-100 <= Node.val <= 100`
> - `-200 <= x <= 200`
>
> **题目来源：[力扣 86. 分隔链表](https://leetcode.cn/problems/partition-list/)。**

在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 `x`，另一个链表中的元素都大于等于 `x`，最后再把这两条链表接到一起，就得到了题目想要的结果。

整体逻辑和合并有序链表非常相似，细节直接看代码吧，注意虚拟头结点的运用：

```python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # 存放小于 x 的链表的虚拟头结点
        dummy1 = ListNode(-1)
        # 存放大于等于 x 的链表的虚拟头结点
        dummy2 = ListNode(-1)
        # p1, p2 指针负责生成结果链表
        p1, p2 = dummy1, dummy2
        # p 负责遍历原链表，类似合并两个有序链表的逻辑
        # 这里是将一个链表分解成两个链表
        p = head
        while p:
            if p.val >= x:
                p2.next = p #让next获得值
                p2 = p2.next #移动指针到next，准备下个循环
            else:
                p1.next = p
                p1 = p1.next
            # 不能直接让 p 指针前进，
            #不能p = p.next 为什么，因为上述接入的节点它仍有next，如p1=p1.next,p1.next后还有个next...，相当于接了一整个链表。
            # 断开原链表中的每个节点的 next 指针
            temp = p.next
            p.next = None #这里必须断开每个节点的next指针
            p = temp
        # 连接两个链表
        p1.next = dummy2.next

        return dummy1.next
```

我知道有很多读者会对这段代码有疑问：

```java
// 不能直接让 p 指针前进，
// p = p.next
// 断开原链表中的每个节点的 next 指针
ListNode temp = p.next;
p.next = null;
p = temp;
```

借助我们的可视化面板看一下就明白了。首先看下正确的写法，你可以多次点击`while(p !== null)`这一行代码即可看到链表分解的过程：

[正确的过程](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#div_partition-list)

如果你不断开原链表中的每个节点的 `next` 指针，那么就会出错，因为结果链表中会包含一个环，你可以多次点击`while(p!==null)`这一行代码查看：

[不断开next指针的后果](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#div_mydata-partition-list)

总的来说，如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。那其实我们可以养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。	

## [合并 `k` 个有序链表](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#合并-k-个有序链表)

​	**23. 合并 K 个升序链表** | [力扣](https://leetcode.cn/problems/merge-k-sorted-lists/) | [LeetCode](https://leetcode.com/problems/merge-k-sorted-lists/) | 🔴

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

**题目来源：[力扣 23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)。**

```python
# 函数签名如下
def mergeKLists(lists: List[ListNode]) -> ListNode:
```

合并 `k` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 `k` 个节点中的最小节点，接到结果链表上？

这里我们就要用到优先级队列这种数据结构，把链表节点放入一个最小堆，就可以每次获得 `k` 个节点中的最小节点。关于优先级队列可以参考 [优先级队列（二叉堆）原理及实现](https://labuladong.online/algo/data-structure-basic/binary-heap-implement/)，本文不展开。

```python
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    # 重载比较运算符，方便将 ListNode 加入最小堆
    def __lt__(self, other): #_lt_方法是定义小于号(<)操作符的行为 
        return self.val < other.val

class Solution:
    def mergeKLists(self, lists):
        if not lists:
            return None
        # 虚拟头结点
        dummy = ListNode(-1)
        p = dummy #指针
        # pq就是优先级队列，最小堆
        pq = [] 
        # 将 k 个链表的头节点加入最小堆
        for i, head in enumerate(lists):
            if head is not None:
                #我们想比较的是什么->节点值head.val #为什么要加入head对象?-> 因为我们从队列里取出最小的那个元素后，需要把这个节点本身（head）接到我们最终的合并链表上。
                #中间那个 i 是干什么的？ 这是一个“保险”措施。在 Python 3 中，如果两个节点的 val 恰好相等，那么排序时会试图比较元组的下一个元素。如果下一个元素是 ListNode 对象，Python 不知道该如何比较它们，就会报错。而 i 是一个独一无二的数字（链表的索引），可以明确地分出大小，从而避免了这个问题。

                #简单来说，这行代码就是把 (节点值, 链表索引, 节点本身) 这个组合放进一个会自动排序的队列里，让我们每次都能轻松拿到值最小的那个节点。
                heapq.heappush(pq, (head.val, i, head)) 
        #主循环：构建新链表
        while pq:
            # 获取最小节点，接到结果链表中
            val, i, node = heapq.heappop(pq) #元组的比较从左到右，所以会优先弹出head.val最小的元组
            p.next = node #将最小的节点接到p.next
            if node.next is not None:#如果是None说明已经处理完了
                heapq.heappush(pq, (node.next.val, i, node.next))
            # p 指针不断前进
            p = p.next
            
        return dummy.next
```

你可以点开下面的可视化面板，点击`while(pq.size()>0)`这一行代码，即可看到有序链表合并的过程：

[Java实现合并链表](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#div_merge-k-sorted-lists)

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 `pq` 中的元素个数最多是 *k*，所以一次 `poll` 或者 `add` 方法的时间复杂度是O*(*l**o**g**k)；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N是这些链表的节点总数。

### 提示

这道题还有一个经典的解法，在 [分治算法核心框架](https://labuladong.online/algo/essential-technique/divide-and-conquer/) 中详细讲解，这里不展开。

## [单链表的倒数第 `k` 个节点](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/#单链表的倒数第-k-个节点)

从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？

那你可能说，假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k + 1` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k + 1` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点。

那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 `k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：![1](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\1.jpeg)

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：![2](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\2.jpeg)

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：![3](C:\Users\26705\Desktop\IDE\TsingPig蓝桥杯py速成\算法做题思维\3.jpeg)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

上述逻辑的代码如下：

```python
# 返回链表的倒数第 k 个节点
def findFromEnd(head: ListNode, k: int) -> ListNode:
    p1 = head
    # p1 先走 k 步
    for i in range(k):
        p1 = p1.next
    p2 = head
    # p1 和 p2 同时走 n - k 步
    while p1 != None:
        p2 = p2.next
        p1 = p1.next
    # p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2
```

你可以点开下面的可视化面板，代码将计算倒数第二个节点。多次点击`i++`即可看到快指针 `p1` 先前进了 2 步，然后多次点击`while(p1 != null)`这一行代码，即可看到 `p1` 和 `p2` 同时前进，最终 `p2` 停在了倒数第 `k` 个节点上：
