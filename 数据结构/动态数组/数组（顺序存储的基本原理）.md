## 静态数组

> 静态数组在创建的时候就要确定数组的元素类型和元素数量。只有在 C++、Java、Golang 这类语言中才提供了创建静态数组的方式，类似 Python、JavaScript 这类语言并没有提供静态数组的定义方式。
>
> 静态数组的用法比较原始，实际软件开发中很少用到，写算法题也没必要用，我们一般直接用动态数组。但为了理解原理，在这里还是要讲解一下。
>
> 定义一个静态数组的方法如下：

```python
# 严格来说，Python 没有静态数组的定义方式
# 我们暂且使用列表模拟静态数组

# 定义一个大小为 10 的静态数组
arr = [0] * 10

# 使用索引赋值
arr[0] = 1
arr[1] = 2

# 使用索引取值
a = arr[0]
```

> 拿 C++ 来举例吧，`int arr[10]` 这段代码到底做了什么事情呢？主要有这么几件事：
>
> 1、在内存中开辟了一段**连续的内存空间**，大小是 `10 * sizeof(int)` 字节。一个 int 在计算机内存中占 4 字节，也就是总共 40 字节。
>
> 2、定义了一个名为 `arr` 的数组指针，指向这段内存空间的首地址。
>
> 那么 `arr[1] = 2` 这段代码又做了什么事情呢？主要有这么几件事：
>
> 1、计算 `arr` 的首地址加上 `1 * sizeof(int)` 字节（4 字节）的偏移量，找到了内存空间中的第二个元素的**首地址**。
>
> 2、从这个地址开始的 4 个字节的内存空间中写入了整数 `2`。





> 我梳理一下上面的因果逻辑，静态数组本质上就是一块**连续的**内存空间，`int arr[10]` 这个语句我们可以得知：
>
> 1、我们知道这块内存空间的首地址（数组名 `arr` 就指向这块内存空间的首地址）。
>
> 2、我们知道了每个元素的类型（比如 int），也就是知道了每个元素占用的内存空间大小（比如一个 int 占 4 字节，32 bit）。
>
> 3、这块内存空间是连续的，其大小为 `10 * sizeof(int)` 即 40 字节。
>
> **所以，我们获得了数组的超能力「随机访问」：只要给定任何一个数组索引，我可以在 O(1)\*O\*(1) 的时间内直接获取到对应元素的值**。
>
> 因为我可以通过首地址和索引直接计算出目标元素的内存地址。计算机的内存寻址时间可以认为是 O(1)*O*(1)，所以数组的随机访问时间复杂度是 O(1)*O*(1)。
>
> 但是，一个人最大的优势往往也是他的最大劣势。数组连续内存的特性给了他随机访问的超能力，但它也因此吃了不少苦，下面介绍。





### 增删查改

> **数据结构的职责就是增删查改**，再无其他。
>
> 那么刚刚介绍数组这种数据结构的底层原理，我们其实只介绍了「查」和「改」的部分，也就是通过索引修改和访问对应元素的值。那么「增删」这两个操作又是如何实现的呢？

#### 增

##### 情况一，数组末尾追加（append）元素

> 比方说，我有一个大小为 10 的数组，里面装了 4 个元素，现在想在末尾追加一个元素，怎么办？
>
> 比较简单，直接在对应的索引赋值就行了，这是大概的代码逻辑：p

```python
# 大小为 10 的数组已经装了 4 个元素
arr = [0] * 10
for i in range(4):
    arr[i] = i

# 现在想在数组末尾追加一个元素 4
arr[4] = 4

# 再在数组末尾追加一个元素 5
arr[5] = 5

# 依此类推
# ...
```

**可以看到，由于只是对索引赋值，所以在数组末尾追加元素的时间复杂度是 O(1)\*O\*(1)**。

##### 情况二，数组中间插入（insert）元素

> 比方说，我有一个大小为 10 的数组 `arr`，前 4 个位置装了元素，现在想在第 3 个位置（索引 2 `arr[2]`）插入一个新元素，怎么办？
>
> 这就要涉及「数据搬移」，给新元素腾出空位，然后再才能插入新元素。大概的代码逻辑是这样的：

```python
# 大小为 10 的数组已经装了 4 个元素
arr = [0] * 10
for i in range(4):
    arr[i] = i

# 在索引 2 置插入元素 666
# 需要把索引 2 以及之后的元素都往后移动一位
# 注意要倒着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for i in range(4, 2, -1):
    arr[i] = arr[i - 1]

# 现在第 3 个位置空出来了，可以插入新元素
arr[2] = 666
```

**综上，在数组中间插入元素的时间复杂度是 O(N)\*O\*(\*N\*)，因为涉及到数据搬移，给新元素腾地方**。

##### 情况三，数组空间已满

> 静态数组在创建时就要确定大小，比方说现在我创建了一个数组 `int arr[10]`（一块 40 字节的连续内存空间），然后往里面存了 10 个元素，这时候我想再插入一个元素，怎么办？无论是追加在尾部还是插入到中间，都没有位置留给新元素了。
>
> 有的读者可能说，这个简单呀，在这 40 字节后面再加上 4 个字节的连续内存空间，用来存储新的元素，不就行了吗？
>
> **不行的，连续内存必须一次性分配，分配完了之后就不能随意增减了**。因为你这块连续内存后面的内存空间可能已经被其他程序占用了，不能说你想要就给你。
>
> 那怎么办呢？只能重新申请一块更大的内存空间，把原来的数据复制过去，再插入新的元素，这就是数组的「扩容」操作。
>
> 比方说，我重新创建一个更大的数组 `int arr[20]`，然后把原来的 10 个元素复制过去，这样就有空余位置插入新的元素了。
>
> 大概的逻辑是这样的：

```python
# 大小为 10 的数组已经装满了
arr = [i for i in range(10)]

# 现在想在数组末尾追加一个元素 10
# 需要先扩容数组
newArr = [0] * 20

# 把原来的 10 个元素复制过去
for i in range(10):
    newArr[i] = arr[i]

# 释放旧数组的内存空间
# ...

# 在新的大数组中追加新元素
newArr[10] = 10
```

**综上，数组的扩容操作会涉及到新数组的开辟和数据的复制，时间复杂度是 O(N)\*O\*(\*N\*)**。



### 删

删除元素的操作和增加元素的操作类似，也需要分情况讨论。

##### 情况一，删除末尾元素

> 比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除末尾的元素，怎么办？
>
> 很简单，直接把末尾元素标记为一个特殊值代表已删除就行了，我们这里简单举例，就用 -1 作为特殊值代表已删除好了。后面带大家具体实现动态数组的时候，会有更完善的方法删除数组元素，**这里只是为了说明删除数组尾部元素的本质就是进行一次随机访问，时间复杂度是 O(1)\*O\*(1)**。
>
> 大概的代码逻辑是这样的：

```python
# 大小为 10 的数组已经装了 5 个元素
arr = [0] * 10
for i in range(5):
    arr[i] = i

# 删除末尾元素，暂时用 -1 代表元素已删除
arr[4] = -1
```

##### 情况二，删除中间元素

> ​	比方说，我有一个大小为 10 的数组，里面装了 5 个元素，现在想删除第 2 个元素（`arr[1]`），怎么办？
>
> 这也要涉及「数据搬移」，把被删元素后面的元素都往前移动一位，保持数组元素的连续性。
>
> 大概的代码逻辑是这样的：

```python
# 大小为 10 的数组已经装了 5 个元素
arr = [0] * 10
for i in range(5):
    arr[i] = i

# 删除 arr[1]
# 需要把 arr[1] 之后的元素都往前移动一位
# 注意要正着遍历数组中已有元素避免覆盖，不懂的话请看下方可视化面板
for i in range(1, 4):
    arr[i] = arr[i + 1]

# 最后一个元素置为 -1 代表已删除
arr[4] = -1
```



**综上，在数组中间删除元素的时间复杂度是 O(N)\*O\*(\*N\*)，因为涉及到数据搬移**。



### [总结]

综上，静态数组的增删查改操作的时间复杂度是：

- 增：
  - 在末尾追加元素：O(1)*O*(1)。
  - 在中间（非末尾）插入元素：O(N)*O*(*N*)。
- 删：
  - 删除末尾元素：O(1)*O*(1)。
  - 删除中间（非末尾）元素：O(N)*O*(*N*)。
- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)*O*(1)。
- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)*O*(1)。

有读者可能问，刚才不是还探讨过数组的扩容操作吗，扩容涉及到新数组空间的开辟和数据的复制，时间复杂度是 O(N)*O*(*N*)，这个复杂度为什么没有算到「增」的复杂度里面呢？

这个问题很好，但并不是每次增加元素的时候都会触发扩容，所以扩容的复杂度要用「均摊时间复杂度」来分析，这个概念我在 [时空复杂度分析方法](https://labuladong.online/algo/essential-technique/complexity-analysis/) 中有详细的讲解，这里就不展开了。

还有个问题初学者要注意，我们说数组的查、改复杂度是 O(1)*O*(1)，这个仅仅适用于给定索引的情况。如果反过来，比方说给你一个值，让你去找这个值在数组中对应的索引，那你只能遍历整个数组去寻找对吧，这个复杂度就是 O(N)*O*(*N*) 了。

所以说要搞清楚原理，而不要去背概念。原理懂了，概念你自己都能推导出来的。
