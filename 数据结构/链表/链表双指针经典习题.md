# 【练习】链表双指针经典习题

## 前置知识

阅读本文前，你需要先学习：

- [链表基础](https://labuladong.online/algo/data-structure-basic/linkedlist-basic/)
- [单链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/)

## [链表的分解](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#链表的分解)

### Tip

链表的分解技巧可以运用到很多单链表题目中，题目并不一定明确地要求你把链表分解成两部分，只要要求你从链表筛选出若干节点，都可以用这个技巧。

## [82. 删除排序链表中的重复元素 II](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#slug_remove-duplicates-from-sorted-list-ii)

> **82. 删除排序链表中的重复元素 II** | [力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) | [LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/) | 🟠
>
> 给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。
>
> **示例 1：**
>
> ![img](https://labuladong.online/algo/images/lc/uploads/2021/01/04/linkedlist1.jpg)
>
> ```
> 输入：head = [1,2,3,3,4,4,5]
> 输出：[1,2,5]
> ```
>
> **示例 2：**
>
> ![img](https://labuladong.online/algo/images/lc/uploads/2021/01/04/linkedlist2.jpg)
>
> ```
> 输入：head = [1,1,1,2,3]
> 输出：[2,3]
> ```
>
> **提示：**
>
> - 链表中节点数目在范围 `[0, 300]` 内
> - `-100 <= Node.val <= 100`
> - 题目数据保证链表已经按升序 **排列**
>
> **题目来源：[力扣 82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)。**

### [基本思路](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#基本思路)

这道题可以有多种解法，最简单粗暴的解法是用 [哈希集合](https://labuladong.online/algo/data-structure-basic/hash-set/) 来记录重复节点，需要额外的空间复杂度，我们不讨论。下面探讨如何用双指针技巧，避免使用额外的空间复杂度来求解。

第一种思路，也是我比较推荐的方式，就是把这种题转化成 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲的链表分解的技巧。题目其实就是让你把链表分解成「重复元素」和「不重复元素」两条链表，然后把不重复元素这条链表返回即可。

第二种思路，可以把这道题理解为 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲的 [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list) 的变体，只不过 83 题让你把多于的重复元素去掉，这道题要求你把所有重复的元素全都去掉。

第三种思路，可以用递归思维来做，稍微难理解一些，我也写出来供大家参考。

**详细题解**：

- [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#解法代码)

```python
# 推荐的通用解法，运用链表分解的技巧
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # 将原链表分解为两条链表
        # 一条链表存放不重复的节点，另一条链表存放重复的节点
        # 运用虚拟头结点技巧，题目说了 node.val <= 100，所以用 101 作为虚拟头结点
        #ListNode(val) <-传入的值代表节点的值多大
        dummyUniq = ListNode(101)
        dummyDup = ListNode(101)

        pUniq, pDup = dummyUniq, dummyDup
        p = head

        while p is not None:
            if (p.next is not None and p.val == p.next.val) or p.val == pDup.val:
                #第二个子条件：p.val == pDup.val pDup 是重复链表 dummyDup 的尾指针，它总是指向最近一个被加入到重复链表中的节点。
                # 发现重复节点，接到重复链表后面
                pDup.next = p
                pDup = pDup.next
            else:
                # 不是重复节点，接到不重复链表后面
                pUniq.next = p
                pUniq = pUniq.next

            p = p.next
            # 将原链表和新链表断开
            pUniq.next = None
            pDup.next = None

        return dummyUniq.next

# 快慢双指针解法
class Solution2:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        p, q = dummy, head
        while q is not None:
            if q.next is not None and q.val == q.next.val:
                # 发现重复节点，跳过这些重复节点
                while q.next is not None and q.val == q.next.val:
                    q = q.next
                q = q.next
                # 此时 q 跳过了这一段重复元素
                if q is None:
                    p.next = None
                # 不过下一段元素也可能重复，等下一轮 while 循环判断
            else:
                # 不是重复节点，接到 dummy 后面
                p.next = q
                p = p.next
                q = q.next
        return dummy.next

# 递归解法
class Solution3:
    # 定义：输入一条单链表头结点，返回去重之后的单链表头结点
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # base case
        if head is None or head.next is None:
            return head
        if head.val != head.next.val:
            # 如果头结点和身后节点的值不同，则对之后的链表去重即可
            head.next = self.deleteDuplicates(head.next)
            return head
        # 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点
        # 越过重复节点，找到 head 之后那个不重复的节点
        while head.next is not None and head.val == head.next.val:
            head = head.next
        # 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了
        return self.deleteDuplicates(head.next)
```

## [链表的合并](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#链表的合并)

### Tip

有些题目虽然不是链表的题目，但其中蕴含了合并有序链表的思想。

## [378. 有序矩阵中第 K 小的元素](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#slug_kth-smallest-element-in-a-sorted-matrix)

> **378. 有序矩阵中第 K 小的元素** | [力扣](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/) | [LeetCode](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) | 🟠
>
> 给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
> 请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。
>
> 你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。
>
> **示例 1：**
>
> ```
> 输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
> 输出：13
> 解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
> ```
>
> **示例 2：**
>
> ```
> 输入：matrix = [[-5]], k = 1
> 输出：-5
> ```
>
> **提示：**
>
> - `n == matrix.length`
> - `n == matrix[i].length`
> - `1 <= n <= 300`
> - `-109 <= matrix[i][j] <= 109`
> - 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
> - `1 <= k <= n2`
>
> **进阶：**
>
> - 你能否用一个恒定的内存(即 `O(1)` 内存复杂度)来解决这个问题?
> - 你能在 `O(n)` 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) ）很有趣。
>
> **题目来源：[力扣 378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)。**

### [基本思路](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#基本思路-1)

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。

矩阵中的每一行都是排好序的，就好比多条有序链表，你用优先级队列施展合并多条有序链表的逻辑就能找到第 `k` 小的元素了。

**详细题解**：

- [【练习】优先级队列经典习题](https://labuladong.online/algo/problem-set/binary-heap/)
- [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

### [解法代码](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#解法代码-1)

```python
from queue import PriorityQueue

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        # 存储二元组 (matrix[i][j], i, j)
        # i, j 记录当前元素的索引位置，用于生成下一个节点
        pq = PriorityQueue()
        #PriorityQueue()是一个优先队列，按从小到大排优先级，与deque不同，deque不会自动排序

        # 初始化优先级队列，把每一行的第一个元素装进去
        for i in range(len(matrix)):
            pq.put((matrix[i][0], i, 0)) #三元组(值,行索引i,列索引j) 优先队列按三元组第一个值排序，值相同时往后继续比较。
        res = -1
        # 执行合并多个有序链表的逻辑，找到第 k 小的元素
        while not pq.empty() and k > 0:
            cur = pq.get() #每次取出最小的三元组
            # 按照元素大小升序排序
            res = cur[0] #值
            k -= 1
            # 链表中的下一个节点加入优先级队列
            i, j = cur[1], cur[2] #从cur中获取最小元素的行索引和列索引
            #检查这一行后面是否还有元素
            if j + 1 < len(matrix[i]):
                pq.put((matrix[i][j + 1], i, j + 1))
        return res
```

## [373. 查找和最小的 K 对数字](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#slug_find-k-pairs-with-smallest-sums)

> **373. 查找和最小的 K 对数字** | [力扣](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/) | [LeetCode](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) | 🟠
>
> 给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。
>
> 定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。
>
> 请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。
>
> **示例 1:**
>
> ```
> 输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
> 输出: [1,2],[1,4],[1,6]
> 解释: 返回序列中的前 3 对数：
>      [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
> 输出: [1,1],[1,1]
> 解释: 返回序列中的前 2 对数：
>      [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
> ```
>
> **提示:**
>
> - `1 <= nums1.length, nums2.length <= 105`
> - `-109 <= nums1[i], nums2[i] <= 109`
> - `nums1` 和 `nums2` 均为 **升序排列**
> - `1 <= k <= 104`
> - `k <= nums1.length * nums2.length`
>
> **题目来源：[力扣 373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)。**

### [基本思路](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#基本思路-2)

这道题其实是前文 [单链表的六大解题套路](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲过的 [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的变体。

怎么把这道题变成合并多个有序链表呢？就比如说题目输入的用例：

```python
nums1=[1,7,11] nums2=[2,4,6]
```

组合出的所有数对可以抽象成三个有序链表：

```python
[1, 2] -> [1, 4] -> [1, 6]
[7, 2] -> [7, 4] -> [7, 6]
[11, 2] -> [11, 4] -> [11, 6]
```

这三个链表中每个元素（数对之和）是递增的，所以就可以按照 [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists) 的思路来合并，取出前 `k` 个作为答案即可。

**详细题解**：

- [【练习】优先级队列经典习题](https://labuladong.online/algo/problem-set/binary-heap/)
- [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

```python
from queue import PriorityQueue

class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # 存储四元组 (数对的和,num1[i], nums2[i], i)
        # i 记录 nums2 元素的索引位置，用于生成下一个节点
        pq = PriorityQueue()
        
        # 按照 23 题的逻辑初始化优先级队列
        for i in range(len(nums1)):
            pq.put((nums1[i] + nums2[0], nums1[i], nums2[0], 0))

        res = [] 
        # 执行合并多个有序链表的逻辑
        while not pq.empty() and k > 0:
            _, num1, num2, idx = pq.get() #从PriorityQueue取出当前最小的数对
            k -= 1 #-1数对 当到0时结束循环
            # 链表中的下一个节点加入优先级队列
            next_index = idx + 1
            if next_index < len(nums2):
                pq.put((num1 + nums2[next_index], num1, nums2[next_index], next_index))

            # 按照数对的元素和升序排序
            pair = [num1, num2]
            res.append(pair)

        return res
```

**类似题目**：

- [剑指 Offer II 061. 和最小的 k 个数对 🟠](https://leetcode.cn/problems/qn8gGX)

## [链表运算题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#链表运算题)

## [2. 两数相加](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#slug_add-two-numbers)

> **2. 两数相加** | [力扣](https://leetcode.cn/problems/add-two-numbers/) | [LeetCode](https://leetcode.com/problems/add-two-numbers/) | 🟠
>
> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> **示例 1：**
>
> ![img](https://labuladong.online/algo/images/lc/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```
>
> **示例 2：**
>
> ```
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> ```
>
> **示例 3：**
>
> ```
> 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
> 输出：[8,9,9,9,0,0,0,1]
> ```
>
> **提示：**
>
> - 每个链表中的节点数在范围 `[1, 100]` 内
> - `0 <= Node.val <= 9`
> - 题目数据保证列表表示的数字不含前导零
>
> **题目来源：[力扣 2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)。**

### [基本思路](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#基本思路-3)

> 逆序存储：链表头节点开始为个位-十位-百位-.....
>
> 顺序存储-链表头节点为最高位-最高位-1-...-个位

逆序存储很友好了，直接遍历链表就是从个位开始的，符合我们计算加法的习惯顺序。如果是正序存储，那倒要费点脑筋了，可能需要 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/) 或者使用栈来辅助。

这道题主要考察 [链表双指针技巧](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 和加法运算过程中对进位的处理。注意这个 `carry` 变量的处理，在我们手动模拟加法过程的时候会经常用到。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会稍显复杂，而有了 `dummy` 节点这个占位符，可以避免处理初始的空指针情况，降低代码的复杂性。

**详细题解**：

- [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 在两条链表上的指针
        p1, p2 = l1, l2
        # 虚拟头结点（构建新链表时的常用技巧）
        dummy = ListNode(-1)
        # 指针 p 负责构建新链表->结果链表
        p = dummy
        # 记录进位 两个数字相加时产生的进位
        carry = 0
        # 开始执行加法，两条链表走完且没有进位时才能结束循环
        while p1 is not None or p2 is not None or carry > 0:
            # 先加上上次的进位
            val = carry
            if p1 is not None:
                val += p1.val
                p1 = p1.next
            if p2 is not None:
                val += p2.val
                p2 = p2.next
            # 处理进位情况 比如val是17，carry就是1
            carry = val // 10
            # 存储当前位的结果 比如val是17，val就是7
            val = val % 10
            # 构建新节点->结果链表
            p.next = ListNode(val)
            p = p.next
        # 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next
```

### [可视化](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#可视化-1)

[Java实现两数相加](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#div_add-two-numbers)

## [445. 两数相加 II](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#slug_add-two-numbers-ii)

> **445. 两数相加 II** | [力扣](https://leetcode.cn/problems/add-two-numbers-ii/) | [LeetCode](https://leetcode.com/problems/add-two-numbers-ii/) | 🟠
>
> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
> **示例1：**
>
> ![img](https://labuladong.online/algo/images/lc/1626420025-fZfzMX-image.png)
>
> ```
> 输入：l1 = [7,2,4,3], l2 = [5,6,4]
> 输出：[7,8,0,7]
> ```
>
> **示例2：**
>
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[8,0,7]
> ```
>
> **示例3：**
>
> ```
> 输入：l1 = [0], l2 = [0]
> 输出：[0]
> ```
>
> **提示：**
>
> - 链表的长度范围为` [1, 100]`
> - `0 <= node.val <= 9`
> - 输入数据保证链表代表的数字无前导 0
>
> **进阶：**如果输入链表不能翻转该如何解决？
>
> **题目来源：[力扣 445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)。**

### [基本思路](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/#基本思路-4)

这道题是 [2. 两数相加](https://leetcode.cn/problems/add-two-numbers) 的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先 [翻转链表](https://labuladong.online/algo/data-structure/reverse-linked-list-recursion/)，这样就可以继续玩第 2 题那一套了，没什么难度。

不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后又回到了第 2 题的加法逻辑。

还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 `dummy` 节点的后面。具体看代码吧。

**详细题解**：

- [【练习】链表双指针经典习题](https://labuladong.online/algo/problem-set/linkedlist-two-pointers/)

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        # 把链表元素转入栈中
        stk1 = []
        while l1:
            stk1.append(l1.val)
            l1 = l1.next
        stk2 = []
        while l2:
            stk2.append(l2.val)
            l2 = l2.next

        # 接下来基本上是复用我在第 2 题的代码逻辑
        # 注意新节点要直接插入到 dummy 后面

        # 虚拟头结点（构建新链表时的常用技巧）
        dummy = ListNode(-1)

        # 记录进位
        carry = 0
        # 开始执行加法，两条链表走完且没有进位时才能结束循环
        while stk1 or stk2 or carry > 0:
            # 先加上上次的进位
            val = carry
            if stk1:
                val += stk1.pop() 
            if stk2:
                val += stk2.pop()
            # 处理进位情况
            carry = val // 10
            val = val % 10
            # 构建新节点，直接接在 dummy 后面
            # 构建新节点->结果链表 头插入与1相比，1是尾插入
            newNode = ListNode(val)
            newNode.next = dummy.next
            #dummy在第一次循环时，next指向的是None
            #移动dummy指针
            dummy.next = newNode

        # 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next
```

