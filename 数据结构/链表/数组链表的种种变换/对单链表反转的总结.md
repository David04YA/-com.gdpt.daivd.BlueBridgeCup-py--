## 迭代反转套路1

常规反转只需要三个指针，pre前驱，cur当前，nxt后继

代码如下：

```python
pre,cur,nxt=None,head,head.next
while cur is not None:
    cur.next=pre
    pre=cur
    cur=nxt
    if nxt is not None:
        nxt=nxt.next
        #返回反转后的头节点
return pre
```

至于如何证明这个代码能实现反转，脑子里压一下栈就好，不再证明

## 递归反转套路1

```python

    def reverseList(self, head):
        if head is None or head.next is None:
            return head
        last = self.reverseList(head.next) 
        head.next.next = head 
        head.next = None
        return last
```

同样不需要证明，可以思考如果一个1-2-3的单链表是如何进行这个函数的。

| **调用栈** | **head** | **head.next** | **操作**                                                    |
| ---------- | -------- | ------------- | ----------------------------------------------------------- |
| **Call 1** | **1**    | 2             | 递归调用 `reverseList(2)`                                   |
| **Call 2** | **2**    | 3             | 递归调用 `reverseList(3)`                                   |
| **Call 3** | **3**    | $\text{NULL}$ | **触发 Base Case** (`head.next is None`)，返回 `head` (3)。 |

向上回溯，Call2里 reverseList(2.next)=3了，这是Call3传上来的。

回溯1：2.next.next=3.next= ;2.next=None

回溯2：1.next.next=2.next=1;1.next=None

形成了3-2-1-None



## 迭代反转套路2

> 适用于反转链表前n个节点

```python
def reverseN(head: ListNode, n: int):
    if head is None or head.next is None:
        return head
    pre, cur, nxt = None, head, head.next
    while n > 0:
        cur.next = pre
        pre = cur
        cur = nxt
        if nxt is not None:
            nxt = nxt.next
        n -= 1
    # 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点
    head.next = cur 

    # 此时的 pre 是反转后的头结点
    return pre
```

和之前的迭代写法一样，不同的是为了实现只反转n个，所以要有计数器确保只执行n-1次

## 递归反转套路2

> 适用于只反转前n个节点

```python
# 后驱节点
successor = None

# 反转以 head 为起点的 n 个节点，返回新的头结点
def reverseN(head: ListNode, n: int):
    global successor
    if n == 1:
        # 记录第 n + 1 个节点
        successor = head.next
        return head

    # 以 head.next 为起点，需要反转前 n - 1 个节点
    last = reverseN(head.next, n - 1)

    head.next.next = head
    # 让反转之后的 head 节点和后面的节点连起来
    head.next = successor
    return last 
```

也是执行N-1次，同时末尾节点指回后面的节点

## 迭代反转套路3

> 适用于反转链表[a,b]这个区间内的节点

```python
 def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if m == 1:
            return self.reverseN(head, n)
        # 找到第 m 个节点的前驱
        pre = head
        for i in range(1, m - 1):
            pre = pre.next
        # 从第 m 个节点开始反转
        pre.next = self.reverseN(pre.next, n - m + 1)
        return head

    def reverseN(self, head: ListNode, n: int) -> ListNode:
        if head is None or head.next is None:
            return head
        pre, cur, nxt = None, head, head.next
        while n > 0:
            cur.next = pre
            pre = cur
            cur = nxt
            if nxt is not None:
                nxt = nxt.next
            n -= 1
        # 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点
        head.next = cur 

        # 此时的 pre 是反转后的头结点
        return pre
```

n,m内共有n-m+1个元素，因为循环中（a,b)，b不会执行，所以直接传入n-m+1

reverseN函数这里用的是反转前n个节点的reverseN写法。

前面写的reverseN方法只能反转前k个节点。

我们把传入的链表为第n个，从n开始反转再返回来的就是想要的链表了。

## 递归反转套路3

> 用于解决反转[n,m]这个区间内的节点

```python
class Solution:
    def __init__(self):
        # 后驱节点
        self.successor = None

    def reverseBetween(self, head, m, n):
        #完成对m的定位后，执行reverseN函数 base case
        if m == 1:
            return self.reverseN(head, n)
        # 递归前进到反转的起点m,触发 base case
        head.next = self.reverseBetween(head.next, m - 1, n - 1)
        return head

    # 反转以 head 为起点的 n 个节点，返回新的头结点
    def reverseN(self, head, n):
        if n == 1:
            # 记录第 n + 1 个节点
            self.successor = head.next
            return head

        last = self.reverseN(head.next, n - 1)

        head.next.next = head
        head.next = self.successor
        return last
 
```

这个写法，想要理解透彻就得理解递归，reverseN和reverseBetween的思路大致一致，通过一个计数器来不断前进。

## 迭代反转套路4

> 用于解决以k为一组反转的链表反转问题

```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        if head is None: return None
        # 区间 [a, b) 包含 k 个待反转元素
        a = b = head
        for _ in range(k):
            # 不足 k 个，不需要反转了
            if b is None: return head
            b = b.next
        # 反转前 k 个元素
        newHead = self.reverseN(a, k)
        # 此时 b 指向下一组待反转的头结点
        # 递归反转后续链表并连接起来
        a.next = self.reverseKGroup(b, k) 
        return newHead

    # 上文实现的反转前 N 个节点的函数
    def reverseN(self, head: ListNode, n: int) -> ListNode:
        if head is None or head.next is None:
            return head
        pre, cur, nxt = None, head, head.next
        while n > 0:
            cur.next = pre
            pre = cur
            cur = nxt
            if nxt is not None:
                nxt = nxt.next
            n -= 1
        head.next = cur 
        return pre
```

**1、先反转以 `head` 开头的 `k` 个元素**。这里可以复用前面实现的 `reverseN` 函数。

**2、将第 `k + 1` 个元素作为 `head` 递归调用 `reverseKGroup` 函数**

**3、将上述两个过程的结果连接起来**。