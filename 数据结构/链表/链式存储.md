# 链式存储

## 与数组（顺序存储）的区别

- 物理上：数组在内存上的连续顺序存放的。链式存储不一定连续存放，可以跳跃存放
- 代码上： 
- 数组可以通过索引来查找元素 
- 链式存储没有索引，只能通过上一个、下一个依次查找通过每个节点上的 `next, prev` 指针（双链表中），将零散的内存块串联起来形成一个链式结构。

## 单链表

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
```

### 数组转换为单链表

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


# 输入一个数组，转换为一条单链表
def createLinkedList(arr: 'List[int]') -> 'ListNode':
    if arr is None or len(arr) == 0:
        return None

    head = ListNode(arr[0]) #头指针/引用：指向链表的第一个节点，初始值为空
    cur = head
    for i in range(1, len(arr)):
        cur.next = ListNode(arr[i])
        cur = cur.next

    return head
```

### 单链表的遍历/查找/修改

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 遍历单链表
p = head
while p is not None:
    print(p.val)
    p = p.next
```

> 如果是要通过索引访问或修改链表中的某个节点，也只能用 for 循环从头结点开始往后找，直到找到索引对应的节点，然后进行访问或修改。

### 增

> 我们会持有单链表的头结点，所以只需要将插入的节点接到头结点之前，并将新插入的节点作为头结点即可。

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 在单链表头部插入一个新节点 0
newNode = ListNode(0)
newNode.next = head
head = newNode

# 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

#### 在单链表尾部插入新元素

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 在单链表尾部插入一个新节点 6
p = head
# 先走到链表的最后一个节点
while p.next is not None:
    p = p.next
# 现在 p 就是链表的最后一个节点
# 在 p 后面插入新节点
p.next = ListNode(6)

# 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

#### 在单链表中间插入新元素

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 在第 3 个节点后面插入一个新节点 66
# 先要找到前驱节点，即第 3 个节点
p = head
for _ in range(2):
    p = p.next
# 此时 p 指向第 3 个节点
# 组装新节点的后驱指针
new_node = ListNode(66)
new_node.next = p.next

# 插入新节点
p.next = new_node

# 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

### 删

#### 在单链表中删除一个节点

> 删除一个节点，首先要找到要被删除节点的前驱节点，然后把这个前驱节点的 `next` 指针指向被删除节点的下一个节点。这样就能把被删除节点从链表中摘除了。

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 删除第 4 个节点，要操作前驱节点
p = head
for i in range(2):
    p = p.next

# 此时 p 指向第 3 个节点，即要删除节点的前驱节点
# 把第 4 个节点从链表中摘除
p.next = p.next.next

# 现在链表变成了 1 -> 2 -> 3 -> 5
```

#### 在单链表尾部删除元素

> 这个操作比较简单，找到倒数第二个节点，然后把它的 `next` 指针置为 null 就行了：

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 删除尾节点
p = head
# 找到倒数第二个节点
while p.next.next is not None:
    p = p.next

# 此时 p 指向倒数第二个节点
# 把尾节点从链表中摘除
p.next = None

# 现在链表变成了 1 -> 2 -> 3 -> 4
```

#### 在单链表头部删除元素

> 这个操作比较简单，直接把 `head` 移动到下一个节点就行了，直接看代码吧：

```python
# 创建一条单链表
head = createLinkedList([1, 2, 3, 4, 5])

# 删除头结点
head = head.next

# 现在链表变成了 2 -> 3 -> 4 -> 5
```



## 双链表

```python
class Node:
    def __init__(self, prev, element, next):
        self.val = element
        self.next = next
        self.prev = prev
```

```python
class DoublyListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
        self.prev = None
        
def createDoublyLinkedList(arr: List[int]) -> Optional[DoublyListNode]:
    if not arr:
        return None
    
    head = DoublyListNode(arr[0])
    cur = head
    
    # for 循环迭代创建双链表
    for val in arr[1:]:
        new_node = DoublyListNode(val)
        cur.next = new_node
        new_node.prev = cur
        cur = cur.next
    
    return head
```

### 双链表的遍历/查找/修改

> 对于双链表的遍历和查找，我们可以从头节点或尾节点开始，根据需要向前或向后遍历：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])
tail = None

# 从头节点向后遍历双链表
p = head
while p:
    print(p.val)
    tail = p
    p = p.next

# 从尾节点向前遍历双链表
p = tail
while p:
    print(p.val)
    p = p.prev
```

> 访问或修改节点时，可以根据索引是靠近头部还是尾部，选择合适的方向遍历，这样可以一定程度上提高效率。

### 增

#### 在双链表头部插入新元素

> 在双链表头部插入元素，需要调整新节点和原头节点的指针：

```python
# 创建一条双链表
head = create_doubly_linked_list([1, 2, 3, 4, 5])

# 在双链表头部插入新节点 0
new_head = DoublyListNode(0)
new_head.next = head
head.prev = new_head
head = new_head
# 现在链表变成了 0 -> 1 -> 2 -> 3 -> 4 -> 5
```

#### 在双链表尾部插入新元素

> 在双链表尾部插入元素时，如果我们持有尾节点的引用，这个操作会非常简单：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])

tail = head
# 先走到链表的最后一个节点
while tail.next is not None:
    tail = tail.next

# 在双链表尾部插入新节点 6
newNode = DoublyListNode(6)
tail.next = newNode
newNode.prev = tail
# 更新尾节点引用
tail = newNode

# 现在链表变成了 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

#### 在双链表中间插入新元素

> 在双链表的指定位置插入新元素，需要调整前驱节点和后继节点的指针。
>
> 比如下面的例子，把元素 66 插入到索引 3（第 4 个节点）的位置：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])

# 想要插入到索引 3（第 4 个节点）
# 需要操作索引 2（第 3 个节点）的指针
p = head
for _ in range(2):
    p = p.next

# 组装新节点
newNode = DoublyListNode(66)
newNode.next = p.next
newNode.prev = p

# 插入新节点
p.next.prev = newNode
p.next = newNode

# 现在链表变成了 1 -> 2 -> 3 -> 66 -> 4 -> 5
```

### 删

#### 在双链表中删除一个节点

> 在双链表中删除节点时，需要调整前驱节点和后继节点的指针来摘除目标节点：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])

# 删除第 4 个节点
# 先找到第 3 个节点
p = head
for i in range(2):
    p = p.next

# 现在 p 指向第 3 个节点，我们将它后面的那个节点摘除出去
toDelete = p.next

# 把 toDelete 从链表中摘除
p.next = toDelete.next
toDelete.next.prev = p

# 把 toDelete 的前后指针都置为 null 是个好习惯（可选）
toDelete.next = None
toDelete.prev = None

# 现在链表变成了 1 -> 2 -> 3 -> 5
```

#### 在双链表头部删除元素

> 在双链表头部删除元素需要调整头节点的指针：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])

# 删除头结点
toDelete = head
head = head.next
head.prev = None

# 清理已删除节点的指针
toDelete.next = None

# 现在链表变成了 2 -> 3 -> 4 -> 5
```

#### 在双链表尾部删除元素

> 在单链表中，由于缺乏前驱指针，所以删除尾节点时需要遍历到倒数第二个节点，操作它的 `next` 指针，才能把尾节点摘除出去。
>
> 但在双链表中，由于每个节点都存储了前驱节点的指针，所以我们可以直接操作尾节点，把它自己从链表中摘除：

```python
# 创建一条双链表
head = createDoublyLinkedList([1, 2, 3, 4, 5])

# 删除尾节点
p = head
# 找到尾结点
while p.next is not None:
    p = p.next

# 现在 p 指向尾节点
# 把尾节点从链表中摘除
p.prev.next = None

# 把被删结点的指针都断开是个好习惯（可选）
p.prev = None

# 现在链表变成了 1 -> 2 -> 3 -> 4
```

