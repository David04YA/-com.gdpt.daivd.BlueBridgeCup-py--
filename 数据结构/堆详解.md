# 堆/优先队列

库导入：from heapq import *

注意：python的heap，默认是小堆顶，即二叉堆堆顶元素小或等于左右孩子

```python
heappush(heap,item)
```

> **二叉堆**是一种特殊的**完全二叉树**或**近似完全二叉树**，它满足**堆特性 (Heap Property)**。
>
> ## 什么是二叉堆 (Binary Heap)？
>
> 
>
> **二叉堆**是一种特殊的**完全二叉树**或**近似完全二叉树**，它满足**堆特性 (Heap Property)**。
>
> ### 堆特性 (Heap Property)
>
> 
>
> 二叉堆的关键在于它必须满足一个固定的序关系，即**堆特性**：
>
> - **父节点**的键值总是保持固定的序关系于任何一个**子节点**的键值。
> - 更简单地说，任何一个**非根节点**的值都必须**大于**或**小于**（或**等于**）它的**父节点**的值。
>
> 根据这种序关系，二叉堆分为两种类型：
>
> - **最大堆 (Max Heap / 大顶堆)**：
>   - **父节点的值** **≥** **子节点的值**。
>   - **堆顶（根节点）\**元素是整个堆中的\**最大值**。
> - **最小堆 (Min Heap / 小顶堆)**：
>   - **父节点的值** **≤** **子节点的值**。
>   - **堆顶（根节点）\**元素是整个堆中的\**最小值**。
>
> ## 二叉树的核心概念
>
> 
>
> **二叉树**可以简单地定义为：**每个节点最多只有两个子分支的树结构**。
>
> 
>
> ### 1. 基本特性
>
> 
>
> - **有根树 (Rooted Tree)**：二叉树有一个起始节点，称为**根节点 (Root)**，它是唯一的，没有父节点。
>
> - **最多两个分支**：任何一个非叶子节点，它拥有的子节点数量不能超过两个（可以为 0 个、 1 个或 2 个）。
>
> - **左右次序**：二叉树的分支具有**左右次序**，即左边的分支称为**左子树 (Left Subtree)**，右边的分支称为**右子树 (Right Subtree)**。这两个子树是**有区别**的，不能随意颠倒。
>
> - **父节点**某个节点的直接上级。**孩子节点**某个节点的直接下级。**左孩子**父节点的左侧子节点。**右孩子**父节点的右侧子节点。**叶子节点**没有任何孩子节点的节点。
>
> - ### 完全二叉树 (Complete Binary Tree)
>
>   
>
>   - **定义**：除了可能的**最后一层**外，所有层都被**完全填满**。且最后一层的节点必须从**左侧开始连续排列**，中间不能有空缺。

`heappush(heap,item)`

- 将item添加到heap中，并保持堆的不变性 <!--不变性指的是对于一个小根堆，我们所有的节点都满足根节点小于左右孩子-->
- 时间复杂度O(logn)

`heappop(heap)`

- 传入一个模拟小根堆的数组，能够弹出并返回小根堆里面最小的元素

- 时间复杂度O（logn)

  `heap[0]`取堆顶元素，时间复杂度O(1)



## 例子

![image-20250929093308197](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250929093308197.png)

```python
from heapq import *
hq = [] #初始化一个空的列表
heappush(hq,5)
heappush(hq,9)
heappush(hq,11) 
heappush(hq,12)
heappush(hq,13)
heappush(hq,15)#将以上元素插入进hq中
print(hq[0]) #输出：[5,9,11,12,13,15] 这里的有序是一个巧合，它不能总是保持有序关系

#获取堆顶元素（最小） O(1)
print(hq[0])#5

#弹出堆顶元素(最小) O(logn)
heappop(hq)
print(hq) #输出[9,12,11,15,13]，如下图所示

#注意：py中堆默认是且只能是最小堆
```

![image-20250929100658555](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250929100658555.png)

```python
#大堆顶，通过取反实现 相反数里的最小值，就是正数里的最大值的思想
nms=[15,13,9,5,11,12]
hq=[]
for x in nums:
    heappush(hq,-x)
print(hq) #[-15,-13,-12,-5,-11,-9]

#获取堆顶元素(最大)
print(-hq[0]) #15

#弹出堆顶元素（最大） o(logn)
heappop(hq)
print(hq)#[-13,-11,-12,-5,-9]
print(-hq[0])

