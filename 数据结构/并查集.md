# 并查集

并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点对应集合中的元素。集合内的元素可达且连通

![image-20250927173650330](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250927173650330.png)

[^1]: 如图所示就是一个并查集，一共有两颗树（两个集合） 可以用它们的根节点代表它，如图左根节点是1，图右根节点是6

union(u,v)合并两个元素所属集合（合并对应的树）

find(x)查询某个元素所属集合（查询对应的树的根节点），这可以用来判断两个元素是否属于同一集合

合并和查询的时间复杂度:近似于O（1）

## 并查集详解

查询：当fa[x]=x表示x节点即是根节点；否则，通过递归调用find(fa[x]),沿着树向上移动，直到找到根节点。

[^如何在并查集里查询一个元素x对应的集合的根节点的问题]: 如图红线所示，我们执行find(4)，然后根据4逐级向上寻找父节点直到1，把根节点的信息逐级返回回去

通常在判断是否可达、连通问题时进行查询，如需要判断u,v是否属于一个集合，通过find(u),find(v)是否相等来判断

![image-20250927212513858](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250927212513858.png)

[^根节点查找]: 如图红线所示

### 实现：

#### 初始化：

每个元素都位于一个单独的集合，表示为一颗只有根节点的树。方便起见，我们将根节点的父亲设为自己

```python
fa=list(range(n)) #[0,1,2,...,n-1]
```

![image-20250928083929345](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250928083929345.png)

### 代码实现例子：

![image-20250928095148204](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250928095148204.png)

```python
#查找x所属集合（对应的树的树根）
def find(x):
    if fa[x] == x: return x #首先去判断father是不是它自己
    return find(fa[x])
```

[^如图例]: find(4)->find(3)->find(1)->1

```python
#代码优化
def find(x):
    return x if fa[x] == x else find(fa[x])
```

```python
#大概实现例子
def find(x):
    return x if fa[x] == x else find(fa[x])
find(4)->fa[4] !=4->find(fa[4])->find(3)
#节点 (x)	父节点 (fa[x])
1	1
2	1
3	1
4	3
5	3
```

#### 合并：

要合并两棵树，我们只需要将一棵树的根节点find(v)连到另一棵树的根节点find(u)，即fa[find(v)]<-find(u)，通常在更新可达、连通关系进行合并

![image-20250928090226587](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250928090226587.png)

```python
#v所在集合合并到u所在集合中
def union(u,v):
    if find(u) !=find(v):
        fa[find(v)]=find(u) #**把其中一个节点的父指针指向另一个集合的根节点
```

### 路径压缩

查询过程中，经过的每个元素都属于该集合，我们可直接更新每个元素，让其父节点指向树根。即fa[x]<-find(fa[x])来减少树根，加快后续查询。最终，我们会将原树压缩成树高越发接近2的树。

<!--实际上只能尽可能压缩-->

[^用来防止数据很极端的情况]: 如常见题目会给N<=10^5 不压缩来操作，每一次都需要把一个很长的单链逐级遍历，时间复杂度很高 这时需要路径压缩思想。在考虑集合的过程中，把中间的结果记录下来，并且进行更新，就能更简洁

![image-20250928094017572](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250928094017572.png)![image-20250928095148204](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250928095148204.png)

<!--代码实现如下-->

```python
def find(x):
    if fa[x] == x:return x #判断是不是根节点
    fa[x] = find(fa[x]) #对于非根节点的节点,递归调用，然后返回给fatherx,完成父指针的变化
    return fa[x]
```

> find(4)->fa[4]<-find(3)->fa[3]<-find(1)->1
>
> 核心思想在于：对某些复杂的单链，会退化到一个O(N)的算法，为了更快的完成，采用这种压缩路径且对原来的集合没有任何影响的方式来完成方法构造



### 并查集递归模板

```python
#并查集模板
fa=list(range(n+1)) #初始化，是否n+1看下标从0开始还是从1开始
def find(x):
    if fa[x] == x:return x #判断是否为根节点
    fa[x]=find(fa[x]) #对于非根节点，进行递归，把结果赋值给当前的空指针
    return fa[x]
def union(u,v):
    if find(u) != find(v) #判断两个集合是否独立
    fa[find(v)]=find(u) #将其中一个集合的根节点指向另一个集合的根节点
```

### 迭代模板

```python
fa=list(range(n))

def find(x):
    root=x
    while fa[root] != root: #若当前的root不是根节点
        root=fa[root] #将root更新为它的父节点，循环完成后它会变成根节点
    while fa[x] != x:
        x,fa[x]=fa[x],root #将当前节点 x 的父指针指向最终的根 root，然后将 x 移动到它原来的父节点，为下一次循环做准备 这个循环会一直执行，直到 x 本身也变成了根节点（fa[x] == x），此时从原始 x 到根节点的整条路径都被“压平”了。
    return root
```

