[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

简单 相关标签 ![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



提示



假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

 

**提示：**

- `1 <= n <= 45`

 

------

面试中遇到过这道题?

1/5

是

否

通过次数

1,971,259/3.6M

通过率

55.5%



# 思路

![image-20250930103829809](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250930103829809.png)

> 当n=3时，有三种方案 111 12 21

假设n=9,我们要解决的问题是从0爬到9有多少种不同的方法。

分类讨论

- 如果最后一步爬了1个台阶，那么我们得先爬到8，要解决的问题缩小成：从0爬到8有多少种方法

- 如果最后一步爬了2个台阶，我们得先爬到7，要解决的问题缩小成：从0爬到7有多少种不同的方法。

  > 把一个规模为9的问题，拆分成了两个子问题，规模分别是8和7

  由于这两种情况都会把原问题变成一个**和原问题相似的、规模更小的子问题**，所以可以**用递归解决**

  > 注1：从大往小思考，主要是为了方便把递归翻译成递推，从小往大思考也是可以的。
  >
  > 注2：动态规划有[选或不选]和[枚举选哪个]两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题使用的是[枚举选哪个]

# 二.递归怎么写：状态定义与状态转移方程

因为要解决的问题都是[从0爬到i]

所以定义dfs(i)表示从0爬到i有多少种不同的方法

## 分类讨论

- 如果最后一步爬了1个台阶，那么我们得先爬到i-1，要解决的问题就缩小成：从0爬到i-1有多少种不同的方法。
- 如果最后一步爬了2个台阶，那么我们得先爬到i-2,要解决的问题缩小成：从0爬到i-2有多少种不同的方法

由于这两种方法是互相独立的（爬的台阶个数不同）,所以根据**加法原理**，从0爬到i的方法数等于这两种方法数之和，即：
$$
dfs(i)=dfs(i-1)+dfs(i-2)
$$

### 递归边界：

$$
dfs(0)=1,dfs(1)=1
$$

从0爬到0有一种方法，即原地不动;从0爬到1有一种方法，即爬一个台阶

> 边界就是，在N从大到小遍历时，什么时候停止。

### 递归入口

$$
dfs(n)
$$

也就是答案



### 递归写法

```python
class Solution:
    def climbStairs(self,n:int)->int:
        def dfs(n):
            return 1 if n==1 or n == 0 else dfs(n-1)+dfs(n-2) #先判断是否达到边界，是则返回1，否则返回递推表达式
        return dfs(n)
```

![image-20250930141517278](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250930141517278.png)

如图所示，递归图例化

#### 复杂度分析：

- 时间复杂度：$O(2^n)$搜索树可以近似一棵二叉树，树高为$O(n)$，所以节点个数为$O(2^n)$ <!--对于共有$n$层的二叉树，其节点共有2^(n+1)-1个-->  

  > 时间复杂度太大，如当n=20时，有2^20=10^6,超过时间限制
  >
  > 思考：为什么计算会这么慢。举例 dfs(9)拆分成dfs(8)和dfs(7)，当dfs(8)拆分时又要再计算一次dfs(7)....不断重复运算很多遍，导致时间复杂度问题
  >
  > 那么在每次dfs前，定义一个全局变量字典，用字典存储已经出现过dfs的值，在每次执行dfs()操作前先去询问字典里是否出现过它，如果出现过直接返回字典里的值，否则进行运算--这是我们的思想
  >
  > 如下图所示
  
  ![image-20250930212248589](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20250930212248589.png)

**最后我们把$2^n$级别的数变成了只有$n$个节点的单列，成功的把时间复杂度从$O(2^n)$优化成$O(n)$——记忆化搜索思想**

在我们执行dfs()时，其实就类似于进行一个DFS搜索，在向上搜索的过程中，要把已经出现过的值记录下来 **在Py中，不像其他语言需要自己定义数组或是字典**

```python
from functools import * #内置的库，py3.8.6可以直接用
class Solution:
    def climbStairs(self,n:int) -> int:
        @lru_cache(maxsize=None) #functools中的lru_cache工具 
        #maxsize=None 允许字典的长度可以无穷大
        #在执行上述两步后，会自动执行记忆化搜索，它每一次在DFS前会自动判断是否在之前的cache缓存中出现过，是就直接返回
        def dfs(n):
            return 1 if n==1 or n==0 else dfs(n-1)+dfs(n-2)
        return dfs(n)
s=Solution()
print(s.ClimbStairs(3))#3
        
```

### 与常规DP问题的区别

常规DP问题类似于f(i)=f(i-1)+f(i-2)，这道题虽然也是从dfs递归角度出发，但在从大到小的过程中，却转换成一个递推关系式 `dfs(n-1)+dfs(n-2)` 这道题也可以变形成斐波那契数列，或跟前三项相关的数列等需要计划搜索的题