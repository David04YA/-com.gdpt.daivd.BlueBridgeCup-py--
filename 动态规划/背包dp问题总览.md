# 背包问题

$N$个物品，价值为$v_i$,重量为$w_i$,背包容量为$W$，挑选物品不超过背包容量下，总价值最大是多少

- 0-1背包：每个物品用0或1次
- 完全背包：每个物品可用0到$+∞$次
- 多重背包：每个物品最多$s_i$次
- 分组背包：物品分为若干组，每一组里面选0或1次 

## 0-1背包

状态表示：$f(i,j)$ 

> f(i,j)定义：就是满足1.只从前i个物品中考虑 2.总重量≤$j$ 的情况下，的选法构成的集合

- 集合：

  - 所有拿物品的选法

  - 条件：1.只从前i个物品中考虑 2.总重量≤$j$

- 表示的属性：所有宣发的总价值的最大值（max)

  最终求解的问题$f(N,W)$ 

  > 在前N个物体里考虑，总重量≤W

状态计算：

> 怎么去状态转移--递推关系式怎么计算

集合的划分问题：如何将集合f(i,j)划分成更小的可计算子集

![image-20251001143555260](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251001143555260.png)

### 思考

$f(i,j)$恰好能划分成两个完备的子集，如上图所示，这两个子集的并集就是$f(i,j)$



$f(i-1,j-w[i])+v[i]$$->$如果选i，背包的总容量减去i物品的重量，同时把i的价值在获得的结果中加上

$f(i-1,j)$$->$因为不考虑i，所以i的weight和value都不再进行计算，直接转移到i-1

> 为什么转移到考虑$i-1$,因为是从前i个物体考虑

```python
#f[i][j]表示用前i个物品，在总重量不超过j的情况下，所有物品选法构成的集合中，总价值的最大值
#考虑f[i][j]对应集合的完备划分：选i，其子集的最大值是f[i-1][j-w[i]]+v[i]，需要在j-w[i]≥0满足
#不选i，其子集的最大值是f[i-1][j]。一定可以满足
f=[[0]*(w+1) for _ in range(N+1)] #二维列表（矩阵）的理解：创造一个f的列表，列表中有N+1个元素,每个元素是一个列表，每个列表中有w+1个元素，元素的值都为0
for i in range(1,N+1):
    for j in range(1,w+1): 
        #这里是为了处理J-w[i]越界问题
        if j-w[i]≥0： #可以选i，也可以不选
        	f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])
        else:
            f[i][j]=f[i-1][j] #只能不选i
print(f[N][W])
```

### (了解)滚动数组优化

滚动数组优化为一维：逆序遍历

由于f(i,j)只和f(i-1,j)有关。如果用滚动数组f(j)优化，去掉第一维度，在同一个i下，如果正序遍历j,在恰好更新f(j)前所有$f(j^‘<j)$存放的是新值$f(i,j^‘)$,所有$f(j’’≥j)$存放的是老值$f(i-1,j’’)$

由于我们希望能够得到$f(i-1,j-w[i])$，所以我们必须逆序遍历j,在恰好更新$f(j)$前，$f(j'≤j)$都是老值，表示$f(j-1,j’)$

所以j的枚举为$range(W,w[i]-1,-1)$

```python
f=[0]*(w+1)
for i in range(1,N+1):
    for j in range(w,w[i]-1,-1):
		f[j]=max(f[j],f[j-w[i]]+v[i])
        #此时f[j]就代表上面的f[i-1][j],f[j-w[i]]就代表f[i-1][j-w[i]]
return f[w]
```



### 恰好装满型01背包

#### 与普通01背包的不同点

普通01背包的要求是不超过背包容量，恰好装满型01背包要严格等于背包容量



可以通过初始值修改，将不合法的$f[i][j]$置为$-∞$，合法的$f[i][j]≥0$，则初始值$f[0][0]$=0 

> 相当于是给一个值j，保证从目标值j开始减下去，恰好减到0才有效，不能减到0的不合法数无效



## 完全背包

**状态表示**：$f(i,j)$同0-1背包

**状态计算**：对于集合的划分，按照第$i$个物品选几个（0，1，....,)划分

朴素做法：$O(N·W^2)$ 

> 时间复杂度大

```python
for i in range(1,N+1):
    for j in range(W+1):
        for k in range(j//w[i]+1): #j//w[i]+1->对于一个重量为w[i]的物体，我当前的背包容量是j，能装多少个这样的物体
            f[i][j]=max(f[i][j],f[i-1][j-k*w[i]]+k*v[i])
returnf[N][W]   
```

**冗余优化**：$O(N.W)$

可以发现后面一坨的最大值等价于$f(i,j-w)$



![image-20251002203301945](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251002203301945.png)

**错位相减法**:所以$f(i,j)=max(f(i-1,j),f(i,j-w[i])+v[i])$

![image-20251002204134597](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251002204134597.png)



简化的关键在于发现一个**子问题**。我们观察**除了第一项 f[i−1,j] 之外的所有项**
$$
M=max(f[i−1,j−w]+v,f[i−1,j−2w]+2v,f[i−1,j−3w]+3v,…)
$$
我们可以从 M 中提取出一个价值 v：
$$
M=v+(f[i,j-w]=max(f[i−1,j−w],f[i−1,j−2w]+v,f[i−1,j−3w]+2v,…))
$$
**那么就有：**
$$
f[i,j]=max(f[i-1,j],f[i,j-w]+v)
$$
代码可以优化成：

```python
for i in range(1,N+1):
    for j in range(w+1):
        f[i][j]=f[i-1][j] #先假设不选
        if j-w[i]>=0:#如果满足条件再考虑是否选
            f[i][j]=max(f[i][j],f[i,j-w]+v)
return f[N][W]
```



## 多重背包

在完全背包的基础上，增加每个物品最多选择的次数限制$s[i]$

暴力做法：$O(N.W^2)$

```python
for i in range(1,n+1): #遍历每一种物品
    for j in range(w+1):#遍历每一个可能的背包容量，从 0 到 w
        for k in range(min(c[i]+1,j//w[i]+1)):#在遍历对于当前第 i 种物品，我们决定选 k 个。 
            #c[i]: 第 i 种物品最多有 c[i] 个，所以 k 不能超过 c[i]。j // w[i]: 当前背包容量 j 最多能装下 j // w[i] 个第 i 种物品。
			 f[i][j]=max(f[i][j],f[i-1][j-k*w[i]+k*v[i]])#取选或不选的最大值
```

