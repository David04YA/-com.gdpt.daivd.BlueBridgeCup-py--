[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

中等 相关标签 ![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)相关企业



你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

## 题意翻译：

在一个数组里选一些数，使这些数的和最大，同时需满足一个条件：选出的数中任意两数序号不相邻，如下图所示

![image-20251001125111848](C:\Users\26705\AppData\Roaming\Typora\typora-user-images\image-20251001125111848.png)

## 思路分析：

> 贪心思想：把奇数下标跟偶数下标的和的最大值分别求出来，然后进行比较就得到最终结果了？ 这个想法是错误的
>
> 如：[1,99,1,1,99,1,99] 偶数和：1+1+99+99 奇数和：99+1+1 
>
> 而实际上的最大和：99+99+99

### 动态规划思想：

**选或不选问题**

`f(i)`模型：

`f[i][1]`表示考虑完前i个屋子，且第i个屋子选的最大金额

`f[i][0]`表示考虑完前i个屋子，且第i个屋子不选的最大金额

**状态转移**

不选，`f[i][0]=max(f[i-1][1],f[i-1]f[0])` 

> 因为第i位不选，所以前面i-1的位置要去判断i-1选不选，从f(i)转移成了f(i-1),如1,99,1,1,99 f[i]=99,f[i-1]=1,f[i-2]=99 显然f[i-1]不选

选，`f[i][1]=f[i-1][0]+nums[i-1]`

> 因为第i位要选，所以第i-1位不能选，否则违反题意
>
> 有没有必要考虑i-2？没必要，根据前缀思想，当我们判断到f[i]时，代表已经考虑了0到i-2的所有值 

**怎么想出这个思路的：**

**1.举反例，发现贪心思想无法正常计算，排除，所以想到“选或不选”模型-前i个物体考虑完，开始考虑第i个物体的模型 ：->定义两个坐标,fi0和fi1来代表不选或选，代表它们不选或选时的最大值—>根据题设写出状态转移方程：当选i时，不选i-1；当不选i时，考虑i-1选或不选**



```python
class Solution:
    def rob(self,nums:List[int])->int:
        n=len(nums)
        f=[[0]*2 for _ in range(n+1)] #定义出数组
        for i in range(1,n+1):#遍历
            f[i][0]=max(f[i-1][1],f[i-1][0])#选不选i-1
            f[i][1]=nums[i-1]+f[i-1][0]
    	return max(f[n][1],f[n][0])#返回最大值
```

